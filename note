1. To include "match.h", need to use -lm to compile

2. In backtracking algorithms, the inner algorithm should not return anything. The inner algorithm should return the outout as input.

3. cmp in qsort():

int cmp (const void *a, const void *b)
{
  return *((int *)a) - *((int *)b);
}

3. qsort prototype: qsort(arr, len, sizeof(arr[0]), cmp);

4. When returning char *, note that char * should also include '\0'. So, when allocating it, allocate one character extra.

5. when assigning NULL to an element of char *, assign '\0' instead;

6. Note that, you need to include 'string.h' in order to use memcpy.

7. memcpy prototype: memcpy(void *dest, const void * src, size_t n);
   memset prototype: memset(void *str, int c, size_t n);

8. remember that there are sprintf () and scanf ().

9. ASCII table has 256 characxters

9. When dealing with equation with index, double check if your equation needs "- 1".

10. Remember what palindrome and anagram means. Two strings are anagrams if their character count of each character is same for the two string. For instance, eat, ate and tea are anagram. 

11. *returnColumnSizes[i] is not right . It should be (*returnColumnSizes)[i].

12. Adjacency matrix may look easier than adjacency list, but they are really not. So, don't try to use adjacency matrix because it's easier. Besides, adjacency matrix requires looping through each element to the matrix row which cause to exceed time limit for large matrix.

13. Sometimes, a problem can be solved using graph. But, it can be solved not using graph and the version is more efficient. 

14. Sometimes, a problem can be solved using graph. and should be solved using graph. But, not really creating graph data structure. Remember the "word search" problem. Apply DFS without creating the graph.

15. Instead of checking col < num_col - 1, check if col + 1 < num_col.

16. If you need visit array for a 2D array (each element of the array is a node), create a 2D visit array, instead of a single array representing a 2D array. It produces cleaner code.

17. Think in terms of array length instead of index. This results clear code and easy to think of.

18. Instead of checking num_chars_grouped <= len - 2, check num_chars_grouped + 2 <= len.

19. For instance, you have two characters containing digits. Need to check if they corresponds to 1-26. You can check the first character and the  check if the second characters are within certain range. Instead, convert the string to its numerical value.

20. Sometimes, a problem may look like backtracking. Then look carefully if there is overlapping substructure. If there is, they can be optimized by memorization or even better can be implemented by DP. 

21. We can create zig zag pattern using two stacks.

22. Check if you can use a fixed number for stack or queue. If yes, alllocate it statically instead of dynamicly.

23. In min heap, each node is smaller than its chieldren. Index to the children can be found as:

                           idx1 = 2 * i + 1;//same as chield1 = 2n
                           idx2 = 2 * i + 2;//same as chield1 = 2n + 1

Again, to get the index of parent from a chield, use i = floor ((n - 1)/2); Can be implemented as i = (last_idx - 1) >> 1;

Note that, a heap is also a complete tree. A complete tree is where all the levels are completely filled except the last level. Example of banced tree is:


               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9 

Complete tree is different from balanced tree. A balanced tree is where difference between height of left subtree and right subtree is at most one for all the nodes in the tree. For instance, these are unbalanced trees:

          4
        /   \
       3     5
      /       \
     2         6 
    /           \
   1             7

       30
      /
     20
    /
   10
Example of balanced tree is:
       4
    /    \
   2      6
 /  \    /  \
1    3  5    7 

Now, how to remove element from min-heap? remove the root. Replace the root with the last element (right most leaf). Then push down the root to maintain the heap property (also known as heapify).

How to insert a new node to the heap> Add the new node to the end of the array (make it right most leaf). Then push it up to restore the heap properties (heapify). 

In heapify, first compare the two chieldren. Find the smallest children. Then compare if the node is larger than the smallest children. If yes, swap them.





 


