1. To include "match.h", need to use -lm to compile

2. In backtracking algorithms, the inner algorithm should not return anything. The inner algorithm should return the outout as input.

3. cmp in qsort():

int cmp (const void *a, const void *b)
{
  return *((int *)a) - *((int *)b);
}

3. qsort prototype: qsort(arr, len, sizeof(arr[0]), cmp);

I often forget which one come first, lenght or size of the element. Remember, length comes first.

4. When returning char *, note that char * should also include '\0'. So, when allocating it, allocate one character extra.

5. when assigning NULL to an element of char *, assign '\0' instead;

6. Note that, you need to include 'string.h' in order to use memcpy.

7. memcpy prototype: memcpy(void *dest, const void * src, size_t n);
   memset prototype: memset(void *str, int c, size_t n);

Note that, memset is good for setting character to a string, but not suitable for setting an integer to an integer array.

8. remember that there are sprintf () and scanf ().

9. ASCII table has 256 characxters

9. When dealing with equation with index, double check if your equation needs "- 1".

10. Remember what palindrome and anagram means. Two strings are anagrams if their character count of each character is same for the two string. For instance, eat, ate and tea are anagram. 

11. *returnColumnSizes[i] is not right . It should be (*returnColumnSizes)[i].

12. Adjacency matrix may look easier than adjacency list, but they are really not. So, don't try to use adjacency matrix because it's easier. Besides, adjacency matrix requires looping through each element to the matrix row which cause to exceed time limit for large matrix.

13. Sometimes, a problem can be solved using graph. But, it can be solved not using graph and the version is more efficient. 

14. Sometimes, a problem can be solved using graph. and should be solved using graph. But, not really creating graph data structure. Remember the word-search problem. Apply DFS without creating the graph.

15. Instead of checking col < num_col - 1, check if col + 1 < num_col.

16. If you need visit array for a 2D array (each element of the array is a node), create a 2D visit array, instead of a single array representing a 2D array. It produces cleaner code. (added later having single array is not bad either)

17. Think in terms of array length instead of index. This results clear code and easy to think of.

18. Instead of checking num_chars_grouped <= len - 2, check num_chars_grouped + 2 <= len.

19. For instance, you have two characters containing digits. Need to check if they corresponds to 1-26. You can check the first character and the  check if the second characters are within certain range. Instead, convert the string to its numerical value.

20. Sometimes, a problem may look like backtracking. Then look carefully if there is overlapping substructure. If there is, they can be optimized by memorization or even better can be implemented by DP. 

21. We can create zig zag pattern using two stacks.

22. Check if you can use a fixed number for stack or queue. If yes, alllocate it statically instead of dynamicly. But, implementing dynamically works fine in case you need to expand it.. (let's do that by default)

23. In min heap, each node is smaller than its chieldren. Index to the children can be found as:

                           idx1 = 2 * i + 1;//same as chield1 = 2n
                           idx2 = 2 * i + 2;//same as chield1 = 2n + 1

Again, to get the index of parent from a chield, use i = floor ((n - 1)/2); Can be implemented as i = (last_idx - 1) >> 1;

Note that, a heap is also a complete tree. A complete tree is where all the levels are completely filled except the last level. Example of banced tree is:


               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9 

Complete tree is different from balanced tree. A balanced tree is where difference between height of left subtree and right subtree is at most one for all the nodes in the tree. For instance, these are unbalanced trees:

          4
        /   \
       3     5
      /       \
     2         6 
    /           \
   1             7

       30
      /
     20
    /
   10
Example of balanced tree is:
       4
    /    \
   2      6
 /  \    /  \
1    3  5    7 

Now, how to remove element from min-heap? remove the root. Replace the root with the last element (right most leaf). Then push down the root to maintain the heap property (also known as heapify in coremen's book, it's called bubble down in Skiena's book).

How to insert a new node to the heap? Add the new node to the end of the array (make it right most leaf). Then push it up to restore the heap properties. It is known as bubble up in Skiena's book. This is not heapify. Note that, insertion needs push_up instead of push_down() needed in heap_delete().

In heapify, first compare the two chieldren. Find the smallest children. Then compare if the node is larger than the smallest children. If yes, swap them. Note that, there can be only one children. So, implement it properly.

Given an array, how to construct a heap from that? First, find the parent to the last element. Apply heapify (bubble down) for that element and all the prior element in bottom up fashion. No need to perform bubble up.

Take a look at kth_smallest_element.c and kth_largest_stream.c.

24. If you need to compare k elements at each step to get the largest or smallest element, use min or max heap. Remember merging of k linked list or arrays.. 

https://www.geeksforgeeks.org/merge-k-sorted-linked-lists/

25. char* strchar (char *str, char c) returns pointer to the first occurance of c in the str. If c does not occur, then it returns NULL. Note that, it is NOT strch()
 
26. char* strstr(char *s, char *pattern) returns pointer to the first occurance of the string pattern in string s. If pattern does not occur, it returns NULL.

27. sscanf usage:

   int day, year;
   char weekday[20], month[20], dtm[100];
   strcpy( dtm, "Saturday March 25 1989" );
   sscanf( dtm, "%s %s %d  %d", weekday, month, &day, &year );
   printf("%s %d, %d = %s\n", month, day, year, weekday );

28. There is no function called isnum() or isnumeric(). There is however isdigit(char c); 

29. parsing multiple string from a string using sscanf can be tricky. For instance,

  char s[4][20];
  int count = sscanf (IP, "%s.%s.%s.%s", &s[0][0], &s[1][0], &s[2][0], &s[3][0]);

  here, &s[0][0] gets the whole IP string.  &s[1][0], &s[2][0], &s[3][0] get garbage value. So, parse the string manually instead. 

for instance, see the following function:

bool valid_ipv4 (char * IP)
{
  int i, j, k, sum, num_dot = 0;
  int len = strlen (IP);
  
  for (i = 0, j = 0; i <= len; i++) {
    if (IP[i] == '.' || IP[i] == '\0') {
      num_dot++;
      if (i - j > 3 || i == j)
        return false;
      if (i - j >= 2 && IP[j] == '0')
        return false;
      sum = 0;
      for (k = j; k < i; k++) {
        sum = sum * 10 + (IP[k] - '0');
      }
      if (sum > 255)
        return false;
      j = i + 1;
      continue;
    }
    if (!isdigit(IP[i]))
      return false;
  }
  
  return num_dot == 4;
}

30. To implement DFS using stack, keep these in mind. 

First off, your stack may need more elements than the number of nodes. So, make the stack size twice as big as the number of nodes.

Second, you don't need two colors for the visit array. A simple visit array is enough. When insert the first element to the stack, don't mark it it visited. You need to mark a node visited when you expand the node after retrieving from the top of the stack. In while loop, get the top of the stack (don't pop it immediately). If the ToS is visited, that means you expanded it before, so pop it (backtracking). Otherwise, push all the adjacent nodes. When pushing adjacent nodes, check if the nodes have been visited yet (depending on your use case, you may want to visit or not visit a previously visited node). If the node we are inserting is visited, it means a cycle.

Note that, when you are popping from the stack, it means backtracking. You need to add add continue (I often forget this) so that it processes the next from the stack.

Example from course-schedule problem:

struct edge {
  int v2;
  struct edge *next;
};

bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize){
  struct edge **adj_list = (struct edge **) calloc (numCourses, sizeof (*adj_list));
  int i, j, curr;
  struct edge *new_edge;
  int *in_degrees = (int *) calloc (numCourses, sizeof (*in_degrees));
  int *visit = (int *) calloc (numCourses, sizeof (*visit));
  int *stack = (int *) malloc (numCourses * 2 * sizeof (*stack));
  int s_idx;
  struct edge *runner;
  
  for (i = 0; i < prerequisitesSize; i++) {
    new_edge = (struct edge *) malloc (sizeof (*new_edge));
    new_edge->v2 = prerequisites[i][1];
    new_edge->next = adj_list[prerequisites[i][0]];
    adj_list[prerequisites[i][0]] = new_edge;
  }
  
  for (i = 0; i < prerequisitesSize; i++) {
    in_degrees[prerequisites[i][1]]++;
  }
  
  for (i = 0; i < numCourses; i++) {
    if (visit[i] == 2)
      continue;
    s_idx = 0;
    stack[s_idx++] = i;
    while (s_idx) {
      curr = stack[s_idx - 1];
      if (visit[curr] == 1) {
        s_idx--;
        visit[curr] = 2;
        continue;
      }
      visit[curr] = 1;
      runner = adj_list[curr];
      while (runner) {
        if (visit[runner->v2] == 1)
          return false;
        //not already visited
        if (visit[runner->v2] != 2)
          stack[s_idx++] = runner->v2;
        runner = runner->next;
      }
    }
  }
  return true;
}

Added later:

This is not always the case. In some cases, in DFS, you can just pop from the stack (like DFS). For instance, number-of-islands problem can be solved using that. This is the case when you do not need to keep track of backtracking. If you need to keep track of backtracking (i.e. do sometimething during back tracking), you cannot pop from the stack immedidiately.

Added later: 

One color is very ofen fine. Just use a visit array. When you visit a node and add all adjacent node, mark it as 1 in the visit array. So, you won't expand it later. Note that, you should not mark a node just after adding to the stack. You should mark it after visit it from the stack (i.e. expanding it). Now, when you get a node from stack and it is marked, it means you are backtracking. So, simply remove it from the stack and add continue (so that you don't proceed further).

Note that sometimes, you may need to implement real backtracking algorithm in DFS. For instance, all-paths-from-source-to-target problem. In that case, you need to implement real backtracking algorithm in DFS. Recall that, in backstracking, when you backtrack, you need to unset the previous state. IN the same way, we need to unset the visit array so that DFS + Backtracking will visit previously visited node again (THis is very very interesting!!!!).

Note that, I am implememing DFS using stack. Not sure, how this will impact recursive solutions. But, need to keep these in mind.

31. For instance, you want to reverse each word in  a string. Here, you should iterate from 0 to strlen(s) + 1. If i-th character is a space or NULL, then reverse the string.

32. If you are asked need to reverse a string, note that, your pointer should be i = 0, j = strlen(s). Often I take j = strlen (s) + 1.

added later
-----------
After long time, no practice, I get confused how to iterate string (I know!!)

i: 0 -> strlen(s) - 1.

Not i: 0 -> strlen(s)

33. For instance, You need to remove leading and trailing spaces. You also need to remove extra spaces between words. you can do it by maintaining a state variable called ignore_space. Initially it should be true. If you get a character, make it false. Again if you get a space, make it true.

34. If you print each trhiplet of an array, it should be like:

  i : 0 to len - 3
    j : i + 1 to len - 2
      k : j + 1 to len - 1

Not, 

  i : 0 to len - 1
    j : i + 1 to len -1
      k : j + 1 to len - 1

34. isalpha() checks if a char is a-z A-Z

35. Sometiomes, a problem can be solve by using two pointers and swaping element... (for instance, sort-array-by-parity). But, the problem can be also solved by quicksort partition.

For details, take a look at https://www.geeksforgeeks.org/quick-sort/ 

Note that, I think, there is a simpler way to do partition. We can partition using two pointers. We initialize i = 0, j = len - 2. For each i, see if arr[i] is smaller than the pivot, incremenmt i; else swap (arr[i], arr[j]), do j-- (note that we are not incrementing i here, so new swapped element will be considered next).  

36. if (a & 1 == 0) will not work!!!!. It should be if ((a & 1) == 0)

37. isalpha() checks if a character is an alphabet

38. It is possible to use sizeof () to calculate the amount of memory a string is consuming. But, you may get wrong results sometimes. So, you strlen instead of sizeof () to calculate the memory size of a string.

https://stackoverflow.com/questions/18525272/getting-wrong-string-length

39. Sometimes you may want to implement a circular array (e.g. design-hit-counter problem). Mapping an element to an index of an array can be tricky. For instance, you want to access i-th element (index starts from 1) where length of the array in len. You can do so by

idx = (i - 1) % len; Not idx = (i % len) - 1.

Also iterating circular array can be tricky. for instace, you want iterate from index "start" to "end".

It should be :

for (i = start; i != end; i = (i + 1) % len) {

}

Note how we are incrementing i.
Also note how we are checking if we reached to the end. Checking if i < len will not work because if start > end, then i needs to be increase to end, then become 0 and then reach the end.

Again, for instance, you have two index i and j. You want to check if (i == j - 1), i.e. if i is the preceding element of j. You cannot do it directly because arr[len-1] is the preceeding element of arr[len-1]. To check such case, you can do this:

if ((i + 1) % len == j)

Also note that, idx_new_elem > idx_last_inserted_elem + len. That is, you are rounding the whole array. So, you may want to store that last inserted element.

added later
------------------
If you think carefully, this problem can be solved in a way more easier way. You can solve it using a dequeue. You need to insert the new timestamp and remove all the elements from the left that is less than (new_timestamp - 300).

Now, if you think carefully, you don't really need a a dequeue. You can simply use a queue to implement that.

https://leetcode.com/problems/design-hit-counter/solution/

40. Don't update input parameters as local variable. Create your own. It is less error prone.

41. If you need to calculate sum or multiplication of int/float, check if you need "long long" (for int) or "double" (for float) to store it. Otherwise overflow happens. If you need long long or double, also change the expression to make sure that longlong or double is stored. For instance,

int a, b;
long long sum;

sum = (long long)a + b; 

42. To print long long, using %lld. To print unsigned long long, use %llu.

To print long, using %ld. To print unsigned long, use %lu.

43. In snake ladder problem, it will be easier to solve the problem by considering each cell a number rather than a row and column. This patterns hold for many cases. If you have a 2D array, think if you can treat each cell as number instead of row col.

Sometimes, number to row-column conversion can be simplified by using slightly differnet equation. For instance, you can do the following:

  row = num / 6;
  if (num % 6 == 0)
    row--;

This can be simplified to 

  row = (num - 1) / 6;

So, if you need a special condition, check if you can find a pattern where the speacial condition goes away.

Also note that you may need to revisit the equation later if the equation works for all the cases.

44. Sometimes, in DP, I make O(n^2) solution where I could make O(n) solution (for instance house-robber and house-robber-ii). In DP, you should not need to look much further in the DP table. You should only need to look for few previous elements to calculate the new element. If you need to look all the previous elements, double check if you could formulate DP such that that is not needed.

Note that, there are two types of DP table we saw so far.

One DP table always stores the best solution so far. It calculates the next entry based on the best solution of the current entry.

Another DP table stores the best solution using the current node. In this case, to calculate the value of a new entry, we need to iterate all the previous entry to get the best solution.

added later
--------------------
DP is generally applied in optimization problem. Best way to find if it's a DP problem or not is not to look for overlapping subproblem and principle of optimality (local optima leads to global optima). Best way is to check if the problem can be solved using bottom-up mannaer. For instance, house-robber and egg breaking problem can more easily solved using bottom up manner (i.e. Start with a smaller problem. Then solve larger problem incrementally). Oh what, this is actaully principle of optimality (so I guess, we check if local optima leads to global optima) 

Regarding, formulating if we should formulate DP as "max value found so far" vs "max value using the current node", think which one should I use. For instance, in house-robber problem I often think that I need to formulate such that DP table stores "max value using the current node". But, note that if I do that, future DP entry will be calculated based on wrong value. So, DP entry should store "max value found so far".

45. Sometimes, a complex problem can be break into simpler problems. Then solve the simpler problem. For instance, break the circular array of house robber II problem into two linear arrays.


46. atoi () returns 0 if convertion is not sucessful. If it returns non-zero, then conversion was sucessfull. Note that we cannot convert "0" with atoi. We need to check that manually. Note that if you pass a string "2+1+3" to atoi(), it returns 2. So, don't use to check if a string is a number or not.

But, if you know that the string is a number and not 0, then you can use atoi(). protottype: int atoi(const char *str).

But, please don't use itoa()!! Use sprintf () instead.

47. Sometimes, you need to find all possible cases of something. You won't need backtracking. But, you can use divide and conquar to break the problem into smaller problems. Then combine the results. You can implement that using recursion. For instance, different-ways-to-add-parentheses problem. These solution can be treated as top-down/recursion/devide and conquer approach.

added later
---------------------------

For instance, you have a expression: 2 + 4 * 7 + 5

I often tend to think that I can break the expression as:

The expression can be broken as:

  +                        *
 / \                +     / \
2   4 * 7 + 5           2+4  7 + 5


That is, at each step, process "a + b * c + d" as "(a) + (b * c + d)" and "(a + b) * (c + d)"

But,  this approach will not work, because it will not generate " ((a + b) * c) + d".

So, the real solution is:

  +                        *                          +
 / \                +     / \         +             /   \
2   4 * 7 + 5           2+4  7 + 5            2 + 4 * 7  5

That is, you need to break it down for each operator. Each part should return a list of output. Based on the operator, we need to merge the output. Please take a look at MY solution of different-ways-to-add-parentheses problem


Note that, here there are overlapping subproblem. For instance, we will evaluate (4*7) or (7+5) multiple times. So, we can think of DP or memorization to improve this. This is not a optimization problem. So, DP is not the way to go. Try recursion + memorization if needed (I never tried it)

In other words, if need to find all the combinations of something, try backtracking first. If it does not work, try recursion /top-down/divide-n-conquer as well.

48. abs() returns absolute value. not mod(). sqrt() calculates square root, not sqart().

49. Sometimes, in DFS and BFS, we also need to store level in a separate array than stack/queue.

added later
------------

Think about it, somtimes it's possible to store the corresponding level in the visit array. If you can, do that. Then, you will not need a separate queue/stack.

50. For instance, you are given a position of a knite in chess (horse). There are 8 possible next moves of the knite. You can find all the possible next move manually by add 1/2/-1/-2... But, better approach is store those numbers in an array and calculate the next index uniformly. Example:

int nm [8][2] = {{2, 1}, {2, -1}, {-2, 1}, {-2, -1}, {1, 2}, {1, -2}, {-1, 2}, {-1, -2}};

Then add the corresponding element.

51. Sometimes, you may tend to use dynamic array to implement the visit array of DFS or BFS. But, don't do that. It causes TLE (lookup in o(n)). Figure out a way to implement array, 2D array or hash to implement the visit array so that lookup in O(1).

added later
------------------
Note that, in DFS we use visit array to check if we have visited it before. In BFS, we use the visit array to check if we have reached the destination. If we don't have a destination in out BFS, we may not need the visit array. And always use a 1D or 2D array for visit so that we can access it at O(1).

52. BFS does not always need queue. You may need to use heap (priority queue) instead. Specially, we need to use heap in BFS in case of A* search. Note that, in A* search, each node will also have a heuristic value. The value is calculated based on two functions: 1) How far it is from start node 2) How far it is from the destination node.

We pick up the node with the lowest heuristic value from the heap.

Note that, the heuristic functiuon can be manhatan distance (abs(x1-x2) + abs (y1-y2)) or euclidian distance (sqrt (pow (x1-x2, 2) + pow (y1-y2, 2))).
Manhantan distance is preferable if we only are allowed to go vertically or horizontally. If we are allowed to go diagonally, euclidean distance is prefereable.

Note, the Dijekstra is a special case for A* search (and BFS). Here, heuristic function only contains the distance from the start node (does not contain distance from that node to end node). In Dijekstra, we can also use a heap to extract the node with lowest weight. 


53. Sometimes, the size of the visited array of BFS/DFS or the size of the stack and queue can be inferred from the constraint. For instance, in minimum-knight-moves problem, contraint is |x| + |y| <= 300. Here, x, y are the target coordinate of the knight. From the constraint, we can assume that the size of the visit array would 605 x 605 (one for initial point. 302 in each way). Note that, in this case, you always need to add 302 with both x and y so that the negative coordinate is shifted to a positive coordinate!!!!!!!

added later
------------------

Note that, it may be tempting to implement minimum-knight-moves problem using A* search. But, don't do that. Stick with basic BFS. You can tell the interviewer that A* can be possible, but don't try that. It will take more time.

Another option!!!! It would be better to implement a bidirectional search!!!!

https://leetcode.com/problems/minimum-knight-moves/solution/

In bidirectional search, we perform BFS from two differenet points. Every time we process a node, we need to check if we reach the visited array of other BFS. If we have, we found the result! Note that, in the visited array, we can store the number of moves needed to reach that point instead of just storing 1/0.

That is, instead of maintaing another array to store the hop along with queue, we can store the hop count in visit array. Note that, here, in the queue, we store x and y.

54. Sometimes greedy solution may be tempting. For instance, coin change problem. However, with few counter example, you will notice that the greedy solution will not work. Next solution would be recursion to compute all possible situation. In that, try to write a mathemetical equation on paper. This really helps. Note that, the equation may need to find minimum/maximum of an expression for all inputs. The recursion generally works because it explores all possible solution. But, the recursive solutions are exponential. So, try to solve this using DP. If the problem follows principle of optimality (i.e. soution is subproblem will be there in larger problem), you can use DP using the recursive equation. (I saw this pattern in several problem)

added later
---------------
So, another pattern appeared. If you have an optimization problem, then it can be DP. Now, you can try to solve it in a bottom-up fashion like house-robber and egg breaking problem; if possible, it's DP. If not, try to solve it using divide-n-conquar/top-down/recursive approach. If poissible, PLEASEEEEEEEEEEEEE wqrite the eqation on the paper. Now check if you can use the equation to implement DP. There are many such problem!!!!!!!

55. Note that in BST, you can use in order travarsal to find a predeccessor or successor of a node. You can also implement predeccessor and successor function directly. For predeccosor, go one step left, then go as much right as you can. For successor, go one step right, then go as much left as you can. Also note that in BST, we may solve a problem partially and not fully done yet. We may need to solve the same problem for other node (subtree) recursively...For instance, delete-node-in-a-bst problem. Note that, recursion here can be tricky. You are passing root of a subtree. The function will perform on the subtree and return the new root. So, you need merge the new root to the previous node. Like:
 
runner->right = deleteNode (runner->right, succ->val);

56. Note that calculating something is often more efficient than determining something. For instance, you need a list of square numbers (i.e. 1, 4, 9..) from 1 to n. I tend to solve this problem by iterating a loop from 1 to n and check if each number is a square number. This is very expensive. Rather count how many square numbers there would be (i.e. sqrt (n)) and the calculate them as 1^2, 2^2, 3^2 and so on.


57. Also note that, you cannot compare an int and float. You should consider using floar(), ceil() or using double instead. I am not sure how to do that yet. Have to look more.

58. Given two ranges: [x1:x2] and [y1:y2]. They overlap if x1 <= y2 && y1 <= x2. Yes! this is true!!!

https://stackoverflow.com/questions/3269434/whats-the-most-efficient-way-to-test-two-integer-ranges-for-overlap

https://stackoverflow.com/questions/325933/determine-whether-two-date-ranges-overlap/325964#325964

So, in summery, the ranges does not overlap if y1 > x2 || x1 > y2. So, they do not overlap if !(y1 > x2 || x1 > y2) is true.

According to, De Morgan's law, !(A  or B) = !A and !B. So, two interval will overlap if !(y1 > x2) && !(x1 > y2) is true. 
In other words, (y1 <= x2) && (x1 <= y2) is true.

Note that, here instead of checking if two intervals overlap can be very complicated. Here, we are checking if two interval does not overlap or not and that makes it way simpler.

Now, how would you find the intersection of two interval? The interval would be: start = max (x1, y1), end = min (x2, y2). Now, another way to check if two interval overlaps by checking if end >= start, if yes, they intersects. 

added later
---------------
Given two ranges: A[x1:x2] and B[y1:y2]. One way to check if they donot overlap is: either B is right of A (y1 > x2) or B is left of A (x1 > y2). Thus, it they will not overlap if: (y1 > x2 || x1 > y2). This is a lot easier to think than the above approach. To check if they overlap, you simply need to add a "!" with the condition. 

Note that, we used the similar approach in rectangle overlap problem  in my point 243.  

58. If you have interval or point, think in terms of [x1, x2] and [y1, y2]. This is easier to think about than [start1, end1] and [start2, end2]. I think, they are also easier than topleftx1, bottomrightx2, ....

59. Sometimes, you will see typical recursion (divide&conquar) is not sufficient. They generate same result twice. In that case, you need to divide the solution into two parts such that one part contains the actual solutiom and the other part is formulated in a way that repeatation is avoided. For instance, coin-change-2 problem. Try to write the recursion equation on paper. If you have an input array, also add the array in the eqation. For instance, you are given an array, arr of size m and an input n. The eqation should look like:

f(arr, m, n) = f (arr, m-1, n) + f (arr, m, n - arr[m-1])

Now, check if this can be implemeneted using DP. Note that, this may seem difficult to implement as DP because here there are two dimentions. In the left sub-part, n does not reduces, so how can you calculate value of f(arr, m, n) based on the f (arr, m-1, n)? The answer is: we need to implement DP in a different way here. First, we should assume that the length of array is 0. Then calculate the DP table. Then in the next iteration, we need to assume that length of array is 1, and update the DP array again. Then, assume that the length of array is 2 and update the DP again and so on...

https://www.geeksforgeeks.org/coin-change-dp-7/
https://leetcode.com/problems/coin-change-2/solution/

When you use DP, also write the equation on the paper. For instance, dp[i] = dp[i] + dp[i - dp[j]]; Note that, in each iteration, we are just consideing one more element (coin) than previous step. That one more element is dp[j] here.

added later
-----------------
Moral of the story: DP is used not only for optimization problem, but also for finding all possible ways to achive something (another example is finding the number of ways you can goto bottom-right from top-left position).

In those kinds of problem, DP is formulated differently. Think about it! The traditional recursive equation cannot be used directly for DP. We rather use one coin at a time to calculate the DP table. This is such an interesting approach!!!!!! 

60. Sometimes dealing with intervals, we can project start and endtime of the intervals into an array to calculate the number of overlap across different time (e.g. meeting-rooms-ii). 

61. Sometimes, problem will give you diffeerent interval and ask how many meeting rooms will you need to accomodate the interval. The problem may sound like backtracking or greedy approach (e.g. meeting-rooms-ii). But, if you think carefully, you will see that this is same as asking the maximum number of overlapping intervals.

62. Note that, sometimes the problem may seem and is very hard. You can always find the brutforce solution. That involves having several loop or recursion. For instance, maximum-profit-in-job-scheduling or weighted-job-scheduling problem.  
 
Now, always write the recursive equation on the paper!!!

Then check if this eqation can be implemented as DP. If yes, implement that. keep in mind that DP always works like magic. The code is simple. And it works!!! Have faith and don't panic :-) The code most of the time works in the first few attempts.

added later
-------------
Note that, maximum-profit-in-job-scheduling problem can not simply be implemented by tranforming equation into DP. In fact this is not DP at all. It is greedy solution!!!!!!

https://www.geeksforgeeks.org/weighted-job-scheduling/

We need to sort jobs by end-time. Then  we need to check the sorted list in order. Here, for each element, we need to check if it makes sense to add the task. How would you do that? This is not simple at all. Here, we also need to maintain a DP like array that corresponds to each task. In order to determine, if you want to add a job to the solution or not, you need to find the lastest preceding job that doesn't conflict with current one and add the DP value with current job. Now compare that to the DP value of the previous job. The maximum is the result.

struct job {
  int start_time;
  int end_time;
  int profit;
};

int cmp (const void *a, const void *b)
{
  return ((struct job *)a)->end_time - ((struct job *)b)->end_time;
}

int jobScheduling(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int* profit, int profitSize){
  int i, j, k, tot_profit;
  struct job *jobs = (struct job *) malloc (startTimeSize * sizeof (*jobs));
  int *dp = (int *) calloc (startTimeSize, sizeof (*dp));
  
  for (i = 0; i < startTimeSize; i++) {
    jobs[i].start_time = startTime[i];
    jobs[i].end_time = endTime[i];
    jobs[i].profit = profit[i];
  }
  
  qsort (jobs, startTimeSize, sizeof (*jobs), cmp);
  
  dp[0] = jobs[0].profit;
  for (i = 1; i < startTimeSize; i++) {
    tot_profit = jobs[i].profit;
    for (j = i - 1; j >= 0; j--) {
      if (jobs[j].end_time <= jobs[i].start_time) {
        tot_profit += dp[j];
        break;
      }
    }    
    dp[i] = dp[i-1] > tot_profit ? dp[i-1] : tot_profit;
  }
  return dp[startTimeSize-1];
} 



63. Sometimes, you cannot draw points using traditional X-Y axis. Sometimes, the element at position is not on the points rather they are on the space between two points. For instance, trapping-rain-water problem. In that case, you need to number the space between two poaints rather the points.

For instance, instead of doing:

----|------|-----|------|-------------
    1      2     3      4

Do this:

----|------|-----|------|-------------
 1      2     3      4

64. Note that, there are fmin(), fmax() that can calculate min/max, however they are in cmath header (C++)

65. char *strcat(char *dest, const char *src)

Here, it appends src to dest. Note that, dest has to be large enough to store the appended string. This is very similar to sprintf ();

I would use sprinf() instead. 

Here, is an examle of strcat().

   char src[50], dest[50];

   strcpy(src,  "This is source");
   strcpy(dest, "This is destination");

   strcat(dest, src);

   printf("Final destination string : |%s|", dest);

66. Always initialize a pointer/string if you are not sure if it will always be assigned before use. You may think that you will add it later if needed. But, doing it in the first place doesn't do any harm and saves a lot of debug time.

67. A catch!!!!!!!

This is fine..
 
sprintf (out, "%s %s", out, str);

This is not!!!

sprintf (out, "%s %s", str, out);

This will produce "str str"!!! You can use another string or use strcat..., but don't do that! Write the logic in a way that you pass out as the first parameter!!!!!

68. Sometimes, logic requires like (e.g. integer-to-english-words problem):

sprintf (out, "%s%s%s", empty ? "" : out, empty ? "" : " ", str);

This makes it complicated. Try to write the logic using if-else... Like..

  if (ten) {
    sprintf (out, "%s", ten_str);
    if (one) {
      sprintf (out, "%s %s", out, one_str);
    }
  } else {
    sprintf (out, "%s", one_str);
  }

69. Sometimes it's nice to write comment in code while coding...

    if (end)
      break;
    //Reverse nodes from runner1 to runner2
    runner2 = runner1->next;

70. When writting iterator for linked list, use runner1, runner2, runner3... in code, but write r1, r2, r3..on paper. Don't use names like prev_node or temp node...even though you are using them as temp (actually this is more of my habit..)

71. Sometime linked list problem get TLE because program  does not set the next of the last node to NULL. Remember to set the next of the last node to NULL.

72. Anytime, you need to check if the index is >= 0 or < arr_length, always check like idx + 1 < arr_len or idx - 1 >= 0. I tend to check with idx which makes it complicated!!!! Keep this in mind. You will do it even though you think you wont :-)

73. Sometimes, solving a problem in a human way is very complex. First step is to find an intuitation to solve the problem. Sometimes, going to solve the intuition can be very difficult. For instance, trapping-rain-water problem. Instead of solving the problem for the whole space, try to solve it for a point in the space. If we can do it, solving for the whole speace is just repeating for each point. So, if a problem looks too dificult, see if you can solve the problem for a point of the problem space.

added later
-----------------
If you think carefully, there is a better solution for trapping-rain-water problem. Here the idea is:

If you find a taller wall than current wall, you find that the border. We can implement this using stack. Push each element to stack until you find an element larger than the first element. If you find an element larger than the first element, pop all the element and calculate the sum. Now this approach will work for following case:

             |
|            |
|  |         |
|  |      |  |  
---------------------

But, it will not work for :

|             
|            |
|  |         |
|  |      |  |     |
---------------------

In this case, stack will have a whole bunch of elements, but they will not be popped. Now, you can solve this in following way. Note that, the problem is same as the previous one, but from right to left. So, keep track of the max = right_most_element and iterate from right to left. Everytime you find an element than is larger than max, you calculate the sum for the boundaries 

Moral of the story:
-------------------------
Note that, if you need to need to compare consecutive elements or compare elements in order, you may solve the problem using Stack or Queue. For instance, trapping-rain-water and remove-all-adjacent-duplicates-in-string-ii problem.

74. Also note that sometimes, an equation can be simpler when you have min/max in your equation. For instance, in trapping-rain-water problem, you need to know the maximum to the left and maximum to the right. In reality, this is not the case. But,as we take minimum of the two, our equation is still valid. 

75. Sometimes, you may inclined to represent intervals as :

----|------|-----|------|-------------
 1      2     3      4

But, you shouldn't! You should represent it as:

----|------|-----|------|-------------
    1      2     3      4

76. Also note that, although an interval is represented as [x, y], it is really [x, y)

77. Remember that, in some case, in DFS, you may want to set visit to false again in case of backtracking. For instance, word-search.

78. Note that, in DFS, when adding adjacent nodes to the stack, check if they are already visited.

79. Sometimes, in DFS, before adding adjacent node to the stack, you can check if you really should add it. For instance, in word-search problem, you know the next letter you will be looking for. So, if the adjacent node is not the next letter, you don't really need to add it. 

Note that, this is same as performing DFS recursively like flood water problem (At each node, we make recursive call on adjacent node). If adjacent node is not the next expecting node, we don't need to make the call. Also node that, here, we pass the visit array as a function parameter or global array so that all the recursive call gets the latest value of the visit array (passing as parameter is preferable). 

80. Trie node:

struct trie_node {
  bool leaf;//not really a leaf. It should be end-of-word (don't call it leaf!!!!)
  struct trie_node *child[26];
};

Note that, trie node may not need value, because select the index to the next node based on the value. The root of of trie is often empty. This is how a trie looks like:

           root
           / | \
         c/  |b \a
         /   |   \
       node node node
       / | \
     c/  |b \a
     /   |   \
  node node node

I very often forget the structure of Trie. I forget that I don't need to store anything in trie_node because I am storing the data in child.. I forget that here child is the most important thing. The child array length can vary. For instance, in case of maximum-xor-of-two-numbers-in-an-array problem, it's a binary trie. So, child size is 2. 

I often tempted to create a separate leaf struct and put it as an instance of trie_node!!!!!!!!!!!!!!!!!! Note that, this is not needed. Just having a bool to indicate that if the node is a leaf or not is enough!!!

Added later:
----------------

Sometimes, you may want to store the content of the leaf because the actual path value is not readily accessible. So, you can also store the left value along with leaf flag. The leaf value is only valid if leaf flag is true. I did that for maximum-xor-of-two-numbers-in-an-array problem.

Also note that, you will always have your root in trie. The root is not added dynamically. So, you can have root statically and then add other nodes dynamically as:

struct node root;  
memset (&root, 0, sizeof (struct node));


81. Take a look at word-search-ii problem. You can solve it by searching (DFS) each word at a time. This would work. But, can you improve it?

For instance, if you have similar words like "dog", "dogs", "dig", "doll", you are search each word separately, but you could have save some computation.

How about constructing a Trie based on the word list (dictionay)? Now you need to search in a Trie while performing DFS in the graph. How would you do that?

I often think that I will search multiple words simultaniously in the graph. For instance, if my Trie looks like:


                       root
                      s/  \d
                    node  node
                   o/ \e   o/  \g
                node  node node node
                          g/ \l
                        node  node
                        
 So, I think, I will look for 's' and 'd' in the graph. Once I find them, I will look for the next characters. Clearly this is not very clear, easy or fisible. What you need to do it you need a way to find one character at a time. One way to solve this problem is to perform DFS in the Trie while performing DFS in the graph.
 
 https://leetcode.com/problems/word-search-ii/solution/
 
 In other words, we need to perform DFS in the Trie and graph at the same time. It is easier to merge the recursive solution of tree travarsal and DFS. That is, you need to perform tree travarsal and graph DFS in recursive form, not iterarive form.
 
82. While visiting Trie, we also need an array that keeps track of the string of the corresponding node.

83. When copying output to res (pointer), make sure that they are allocated in memory. Sometimes, you may just want to return pointer. You don't need to allocate memory in that case.

84. Don't forget to check nengivate condition first and then continue or return. If you proceed, that means you find a positive case. This requires fewer nested indentation.

85. Don't use *ret_size because it may not initialized properly. Use your own res_cnt. Then update *ret_size.

86. When inserting multiple strings to a trie, don't create a node if it already exists. That's the point of trie. But, I often create node for each character in each string.

87. Merging the intervals by projecting them on an array is an efficient solution. But, if each interval is very large, this may not be a good solution. You may want to merge the intervals manually in that case. You want to sort the intervals by start time in that case.

https://www.geeksforgeeks.org/merging-intervals/

88. Some problems seems easy to be implemented using recursion (not backtracking!!). For intsnace, in word-break problem, you can encode a dictionary with a trie. How would you search in the Trie?

 Trie search may need to make recursive call on a subproblem when you reach a node that denotes end of a word. This is because this node may not a leaf. So, you may want look further. So, do you try with the shortest word first or do you try with longest word first?

I tend to think that I should try longest word first. And then backtrack if I can't go further. Bad idea!!! You can perform recursion instead of backtracking.

Again, I think, I will perform two a recursive call. One that goes further, another that assumes that this is the end, so try to look for a new word from the root. This is a better approach, but you can do better in case of Trie search!!!!!!!

I even think I need to implement a DFS in Trie which is an OK idea!!!!!

This is good idea for Trie search:

call search for the rest of the subproblem. If it returns true, then return true. Otherwise, proceed to the child of the current node. If you think carefully, this is actaully a DFS. Here, each node has two possible choise. Here, we are statically choosing one over another.

This recursive call many same subproblem when trie is like:

   root
    |
    |a
    |
   node
    |
    |a
    |
   node
    |
    |a
    |
   node

For instance, if input is aaab, it will call search function for aaab, aab, ab, a, b, b, ab...


https://www.geeksforgeeks.org/word-break-problem-dp-32/

https://www.geeksforgeeks.org/word-break-problem-trie-solution/

This problem can be solved using memorization. So, if you solve a problem once, save the result. This may look trivial.but don't do it!!!!!!!


Yes, don't do it!!!!!! Once you figure how to use recursion, try to figure DP. It's way ceasier. And way easier to implement!! Yes, it's way easier to implement!!! So, don't try to implement a DP problem with recursion!!!!! DP is way easier.

https://leetcode.com/problems/word-break/solution/

added later
------------------
Sometimes, I have hard time finding the DP equation. I cannot find the pattern bottom up. But, note that, the equation of DP usually come from top-down (recursive) solution. So, find a recursive (top-down) equation of the problem. Then solve it using DP.

89. Sometimes, I may send different pointer when making recursive call. Like: 

trie_search (root, &s[i+1], mem);

Don't do it! Do this instead:

trie_search (root, s, i+1, mem);

90. Sometimes, you may be asked to produce all combination of something. You need to know that finding all combination of something requires you to identify something first. For instance, in word-break-ii, you are asked to find all the ways you can break a string according to a dictionary. To solve the problem, we can solve word-break first, then use that to find all the combinations.

Now, if you do this, it will be very overly complicated. I may think this way, but there is a better way. try to find algorithm in fresh mind.

Note that, when you are asked to find all combinations, it's generally backtracking algorithm. So, try to use backtracking...

Note that, backtracking can also be think of as recursion or DFS. Sometimes, you may have an array. You may think you need to implemenet DFS/BFS on the array, but, they can be implemented as recursion (aka DFS). For instance, word-break-ii

Now, note that, anytime you have a recursive solution, check if there is overlapping subproblems. This tend to be very expensive. If there can be overlapping subproblems, implemenet them using DP. Besides, DP is a lot more easier than implementing recursion. In recursion, you are taking a complex problem, and dividing into smaller problem (top-down). On the other hand, in DP, you are starting with a smaller problem, and solving the bigger problem with smaller problem (bottom-up). This tend to be way easier!!!!!!!!

91. When iterating a trie using runner, if you find a match, you should move the runner to the next node immediately because that's the actual node. Then you can check if that node denotes the end of a word.

92. If you want to create a substring from a string, you can use memcpy() or strncpy().

strncpy(char* dest, char* src, int n) is from <cstring>.

Also note that if you use memcpy(), be sure to add NULL manually.

93. Sometimes you may need list of string (or something). You don't have vector in C. So, what you do is have large ***str_list. Allocate them dynamically and use them like an array. This is not much difficult to do compared to vector. Only problem is you need to be aware to pre-allocate as much memory as you might need.

added later
-------------------

I often freck out if I need vector in C. Don't sweat. Create a dynamic array big enogh to store all the elements. Use it like an array. If interviewer ask you to implement a vector, just implement that..

94. It can be more convinient to try to solve a problem based on bottom up approach. This is actaully DP. This actually way easier. A lot complicated problem can become surprisingly simple if you think in bottom up approach. For instance, count-of-range-sum.. So, think bottom up!!!!!!

95. When DPing half of a 2D array in diagonal mannager, use row, col for index along with i. For instance,

  for (i = 1; i < numsSize; i++) {
    for (row = 0, col = i; col < numsSize; row++, col++) {
      idx = row * numsSize + col;
      dp[idx] = dp[idx - 1] + nums[col];
    }
  }

Here, we are filling top-right part of the matrix.

95. How a negative number is stored in computer? It's store in two's complement format. For instance, 4 = 100. -4 = 1111111...1100 (one's complement is 11..1011. two's complement is 11..1100)

Again, 20 = 10100. -20 = 111...01100. 

So, there are several lessons:

a. If a number starts with 1, it's a negative number.
b. Content of a positive and negative number may differ in more than just sign field (MSB).
c. If a number is power of two, it's positive and negative number will only differ in signfield (and 111)
d. You can unset the right-most set bit by n - (n & -n). This is used in Binary index tree to calculate index to the parent. (ignore this. Follow the n & (n-1) approach) 

On a similar note, n & (n - 1) unsets right-most set bit.

https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/


So, basicly, two's complement store the same number

96. If you are asked to develop range sum, you should ask if the array is immutatble. If the array is immutatble, the create prefix sum. Then, you can calculate any range sum at O(1). 

But, if the array is not mutable, then you need to create Binary Index Tree (BIT). BIT supports range query and update at O (logn). You can also use merge sort to implement this. Merge sort is more efficient, i think. (ignore BIT!!)

97. Sometimes, it's ok to create an array that is 1 eleenet larger (1 based array) if that makes the logic simpler.

98. In merge sort, you can merge two arrays in place. This is more efficient. But, sometimes, you may need to implement additional logic. It's OK to use an extra array to merge two arrays and implement that logic if that make the logic simpler (counting the number of smaller elements to the right). 

99. Sometimes, itrating array forward to caluclate O(n) while iterating the array backwords needs O(1). For instance, merging two arrays to calculate the number of smaller elements to the right, iterating array from the right allows us to caluclate the number at O(1). 

100. In merge sort, you can pass a preallocated temp array so that you don't need to alloccate a new array in every recursive call. Also note that this can be more efficient way of merging because merging two sorted arrays in place is not linear while this is. 

101. Suppose you have two sorted arrays A and B. You need to find the number of pairs such that lower <= B[j] - A[i] <= upper. We came across this problem in count-of-range-sum problem. 

Here, we will maintain a variable lo which indicates the index to the first element B for which B[lo] - A[i] >= lower for an iteration. Note that lo is not initialized to 0 in each iteration. It rather starts from where it stopped in the last iteration. We can do this because A is sorted. So, elemements to the left of lo will produce even lower B[j] - A[i] for the next element of A.

Algorithm:

  lo = 0;
  for (i = 0; i < A_len; i++) {
    while (lo < B_len && B[lo] - A[i] < lower)
      lo++;
    for (j = lo; j < B_len; j++) {
      if (B[j] - A[i] <= upper)
        count++;
      else
        break;//Once we reach an element where difference is larger than the upper, no need to go further because the differtence will increase
    }
  }

102. Sometimes, long is not enough. You need long long specially when multiplying by 2.. Note that, you can compare an int and long long. So, when comparing two variables, both does not have to be the same type. 

Also keep in mind that changing variable type to long long from int does not help by itself. You also need to perform casting in the original operation. For instance:

tmp = (long long)nums[j] * 2;

103. Note that, left-shift and right shift of negative number is undefined. So, don't use them if the number can be negative. Instead multiply by 2 or 5 or use division.... (plain old)


104. You don't really need a temporary long long variable. You can just cast in-place and compare. For intance:

if ((long long)nums[hi] * 2 >= nums[i]) is fine!!!!

105. Suppose, in merge sort approach, you often need to compute something based on two sorted arrays. For instance, in reverse-pairs problem, you will have two sorted arrays A and B. You need to count the number of pairs for which B[j] * 2 > A[i].

You can do this by following code:

  int hi = end;//only need to initialize once. In next iteration, start from when we stopped 
  for (i = mid; i >= start; i--) {
    while (hi >= mid + 1 && (long long)nums[hi] * 2 >= nums[i])
      hi--;
    if (hi >= mid + 1)
      *count += (hi - mid);
  }

106. Sometime, we iterate from i: 1-n to move each element one step left and insert a new element. Note that if array size is 1, this loop will not enter at all. Need to keep in mind to write the moving logic

107. Sometimes, you will be asked if you can solve the problem without using a hash-map. One solution is to use the input array as hash. For instance. if an element is seen, you can make the corresponding (original) array element negative. Thus negative element will indicate if the number has been seen or not. For instance, find-all-numbers-disappeared-in-an-array problem.

108. Sometimes, don't be too quick to judge between stack or queue. Play a simulation. Sometimes, it seems you need a queue, but you really need a stack..

109. When grouping string or list, check that if need to sort them first. For instance, when making group of anagrams, you don't need to check strings with different lengths. So, sorting the string first helps!!!

110. Don't use itoa() to convert int to char*. Use sprintf () instead.

111. When sorting a 2D arry using qsort (), you need to pass the size of the pointer instead of the size of the internal array. For instance, 

  char **num_str = (char **) malloc (numsSize * sizeof (*num_str));
  for (i = 0; i < numsSize; i++) {
    num_str[i] = (char *) calloc (12, sizeof (char));
    sprintf (num_str[i], "%d", nums[i]);
  }

  The qsort should look like:

qsort (num_str, numsSize, sizeof (char *), cmp);

It should not look like!!!!:

qsort (num_str, numsSize, 12 * sizeof (char), cmp);

Also, in this case: the cmp will be passed char**. So, it should look like:

int cmp (const void *a, const void *b)
{
  int i, j;
  char *num1 = *((char **)a);
  char *num2 = *((char **)b);
 .......
}

Not :

int cmp (const void *a, const void *b)
{
  int i, j;
  char *num1 = (char *)a;
  char *num2 = (char *)b;
 .......
}

Keep this in mind about cmp:

int cmp(const void* p1, const void* p2);
Return value meaning
<0 The element pointed by p1 goes before the element pointed by p2
0  The element pointed by p1 is equivalent to the element pointed by p2
>0 The element pointed by p1 goes after the element pointed by p2



112. When comparing character, I often forget '' more specially if the character is a digit. For instance, do ch == '0', not ch == 0


113. Note that, strcpy () is strcpy (char *dst, char *src). It does not need size of the string like memcpy. I often add an extra parameter string len * sizeof (char) which is not right.

114. Sometimes, implementing a logic can be too complicated. We can make it simple by creating extra data structure and compare them. For instance, in largest-number problem, we have two strings: x and y and we need to determine if xy > yx..

One solution is two have two pointers one pointing x and another pointing y..At each iteration we compare the value of the pointer. If the values are not the same, we get our answer. When the first pointer reach the end of x, make it to point y. In the same way, when the second pointer reach the end of y, make it point to the x.... But, this logic can be still compilcated to decide which one is better.

Another simpler solution is to just create xy and yx string and compare them. 


The first approach is obviously better, but the second approach is simpler!

115. Binary Subtraction:
0  0 = 0
1  0 = 1
1  1 = 0
0  1 = 1 (Borrow 1)

1011 - 11
0100 - 4
-----------
0111 - 7

115. To return a negative of a variable, we can do this: "return -a;" No need to do "return a * -1;"

116. In do-while loop, I forget semicolon after while. It should be:

do {

} while ();

117. If you need to perform bitwise operation, the operand cannot be negative. Make them positive by abs() and handle negative and positive values separately.


118. I often get confused with Xor (^) operation. I feel like preceeding 0s of a number will produce preceeding 1s in the result. But, actually preceeding 0s creates preceeding 0s in the result because 0 ^ 0 = 0.

119. if (!head || !(head->next)) is fine. We don't need to write if (!head || (head && !(head->next)))

Right side of the || will only execute if !head is false 

120. Sometimes, it ,may seem that initiazing to sometihing to -1 makes more sense than initializing to 0. Think hard if this is really the case. I often find later that initializing to 0 is just fine and works even better. Implementation is often simpler.

On an another note, sometimes, it may seem that storing partial result - 1 is more convinient and then get the final result by partial result + 1. But, this is often unnecessary. In many cases, I found that storing the actual result is just fine.

121. When doing DFS, think if you need to visit a previously visited node again. It depends on the application. Sometimes, you may want to backtrack and visit a previously visited node. In that case, when backtracking, you need to set visit[node] = 0 while backtracking. 

If you don't want to visit a previously visited node again (e.g. course-schedule-ii problem), you may want to store visit[node] = 2 when visiting that node. Later, if you encounter visit[node] == 2, it means you already expanded and vsited and added to the result. If you encounter again, just skip this.

If you want to check cycle in DFS, when exapnding face (adding successors to stack), check if it's already visited; if yes, it's a cycle.

122. Sometimes, iterative implementation of DFS/BFS can be too difficult. You may consider recursive implementation. For instance, longest-increasing-path-in-a-matrix problem. I came across similar issues before.

Sometimes, iterative implementation is not adequete at all!!!! For instance, think about a situation where you need to make a decision based on different branches of DFS. For instance, in longest-increasing-path-in-a-matrix problem, we need to keep track of longest path originating from each node. That is, we need to handle multiple braches at each node and then make decision on the branches. Iterative solution will simply iterarte nodes of each brach one at a time. Although it can detect backtracking, but it's hard to track where we are staring to visit aother brach... Implementing longest-increasing-path-in-a-matrix in iterative mode is very hard to implement. On the other hand, it's switable to be implemented using recursive approach because recursive approach handle multiple branches separately and then process themm...

123. If your input is a matrix, don't use 1-D array for visit or string anything. It may seem convinient, but believe me, it will make the code look uglier later. Instead create a 2D matrix. It's also easy to implement and produces easier code.

124. Sometimes, you can solve a problem with recursion (like backtracking). You can also notice that you can solve the problem in bottom-up manner like DP. But, in that case, in each entry, you need to store 2^n values. This means that you are not actually reducing computation. Here, DP = Recursion. This is need to be done by recursion because you need to check all the combinations. Example of such problem is target-sum problem.

125. Sometimes, it may seem that constructing graph is the right choice because graph algorithm may need to access adjacent nodes which may noyt be readily avaiulable. In that case, you may wonder how do we map data to node. One way to do is, just use original data's index as node index. Don't worry about original data at all. Simply use data's index as node ID to create adjacency list. Note that, adjacent list can simply contain the index. And we can get the corresponding data from the index. One such example is word-ladder problem.

Now think really hard? Do you really need to construct a graph. Once you have a graph, you can access all the adjacent nodes usimng a simple for loop. That's all a graph does for you. You actually ran some sorts of for loop to create the adjacency list anyway. So, actually you don't really need to create the adjacency list anyway even though you think you do. You can simply iterate over the data to get the adjacent nodes.

Moral: You almnost never need to construct a graph data structure. Implement you graph algorithm on the data directly.

126. vector.size() can be used to iterate a vector. There is no vector.count(). Note that, there is also vector::capacity...

127. For instance, you are given bunch of intervals. You are asked to calculate free intervals. For instance: employee-free-time problem.

This can be solved by projecting all the intervals onto an array. But, not that this process is not cheap. Specually if an interval itself is very large. It can be more easy and efficient to handle intervals manually. For instance, you can sort sort the intervals by start time. Then keep track of end time you found so far. If next interval start time is larger than the current end time, we found a free time (simple!!)

128. I did numerous times, still worth reminding that to visit a 2-D array, it should be like:

for (i = 0; i < num_row; i++) {
  for (j = 0; j < num_col; j++) {

  }
} 

That is, iterate row first. Then iterate columns.

129. Sometimes, recursive formulation follows like edit distance. If I have two string s1 and s2. Their edit-distance d[i][j] indicates edit distance of first i characters of s1 and j characters of s2. The formula here is:

d[i][j] = d[i-1][j-1] if s1[i] == s2[j]
d[i][j] = min (d[i-1][j], d[i][j-1]) + 1 if s1[i] != s2[j]

Note that, we consume both characters only if both are same. If both are not same, we don't consume both. We keep one same, and consume other and do the opposite and then take minimum.

I think, this..but, above formulation is wrong!!!!!!!!!!!!!

It should be:

d[i][j] = min (d[i-1][j-1], d[i][j-1] + 1, d[i-1][j] + 1) if s1[i] == s2[j]
d[i][j] = min (d[i-1][j] + 1, d[i][j-1] + 1, d[i-1][j-1] + 1) if s1[i] != s2[j]

For details, take a look at edit-distance problem!!!

Another issue!!!

In edit distance, you need to measure assume that string can be empty. If you try to use m x n mattrix where m and n are lengths of the string, it will not work. you should consider empty string as well. So, the matrix should be m + 1 x n + 1.

Please see https://leetcode.com/problems/edit-distance/solution/

130. Common trick: If solution does not work for a complex input, find a minimal input for which the program also breaks

131. You are asked to design twitter (e.g. design-twitter problem). Here, user can follow and unfollow and post tweets. In user's feed, 10 latest tweets of this own who he is following ought to be shown. 

In this case, you can design it in two way:

a. Design a data structure where each user's feed is precaluclated.
b. Design a data structure where each user's tweet is store and feed is calculated at runtime.

Approach (a) may be tempting, but note that problem with that is, when a user unfollow someone, the feed has to be updated. So, we need to remove that followee's tweet from the feed. On top of that, you need to fill the empty spaces of the feed with tweets of his own or his followees.. In a word, it makes it very complicated to unfollow someone.

On the other hand, in approach (b), you simply need to store the tweets. The feed is calculated at runtime. So, unfollowing process is not comlicated at all.

131. For instance, you need to store 10 latest items. You can implement this using circular array, dequeueu or double linked list. Double linked list can be used as dequeue (i.e. insert to the front and remove from the end). BUt, you simply can store them as a list and always insert at the beginning. If you need to implement a dequeue, you can use double linked list. That way, you can delete from tail. 

132. Suppose, you have k sorted list. Now, you need to retrieve n smallest elements from there list. This is a very common problem appears within a problem. Common way to solve this is to have k pointers each pointing a list. In each iteration, we need to compare k elements where pointers are pointing. That's how we get the smallest element. We will increase the pointer with smallest element. THis solution will take o(nk).

There is better approach!!!!

Use heap of size k. Insert the first element of each list into the heap. Then in each iteration, extract the minimum from heap amd insert the next element from the list where the extracted element belong to. This approach requires, O(nlogk)

133. Sometimes, a problem may involve doing sometihing with even/odd index, but the problem does not say it explicitly. For instance, wiggle-sort. If there is some sorts of pattern, the problem can be solve using even/odd patterns. 

134. Sometimes, you may try to solve a problem by rearranging the elements. But, that will require O(n^2) and still may not be solvable. There may not be a predicatable results in interaative approach. In iterative approach, you may need to iterate forward and backword. They are not easy as sorting. Example of such proble include wiggle-sort and reorganize-string. 

The problem may become easier if you sort them. For instance, in case of wiggle-sort.

Sometimes, you don't really need order. In that case, a map of character with their count may help. For instance, reorganize-string problem.

135. A tree can be travarsed two ways. DFS and BFS. Pre-order, in-order, post-order travarsals are variants of DFS. Again, recursively calling a function on left and right subtree can be think of as preorder or in order travarsal. But, sometimes you may need to do BFS as well. For instance, you need to travarse level order. You can do that by BFS.

136. In wiggle sort (wave-like sort), you can simply sort an array and then the swap every two adjacent elements.

           4                     4 
       3                             3  
    2             ->       2     
 1                            1   

Now, note this this will not work if input has many same element. For instance,

      2 2 2 2            2   2 2 2
1 1 1             -> 1 1   1 

One solution to this problem is: notice that all the odd indeices will contain larger elements and even indices will contain smaller elements (or otherwise)

I tried to solve this without extra space, but I found it tooooooooooo tough through it seems not. This is what I tried:

I sorted the array. Then find out where the larger number will begin. Now, all I need to do is fill up the odd indices with the larger numbers. But, this is easier said than done.

For instance, I iterate odd indices from left and iterate larger numbers from right and swap in every iteration. But, this does not work because a large element will be swapped out.

So, I iterate odd indices from the left and large elements from left. It works for some cases, but still results in same element being placed adjacently. To solve the problem, I tried to reverse the larger numbers. That solves the problem for some cases, but problem still exists. Then tried to reverse smaller problems. It solves the problem, but still problem exists.

So, I give up in place wiggle sort!!!!! Need to try using extra space.

Now, wiggle sort can be thought as we have two sorted array A and B (A contains smaller elements and B contains larger element). We need to merge this two arrays by taking one element from each array at a time and placing them adjacently. There are 4 differert ways we can do that:

A           B
---------------
L-R        L-R  (should work, but doesn't in leetcode)
L-R        R-L  (Not good)
R-L        L-R  (Not good)
R-L        R-L  (good)    

Note that, largest element of A can be same as smallest element of B. 

If we do R-L for B and L-R for A, then there is a good chance that same element will be placed adjacently. So, if we do R-L for B, we should do R-L for A.

Again, if we do L-R for B and R-L for A, then there is a good chance that same element will be placed adjacently. But, L-R for A and B should work, but not for small array. And I found it does not work in leetcode test code.

136. In post order, root is visited at the last. But, it sounds linke something else.

137. In-order, pre-order, etc can be same for differenet trees. But, in-order and post-order would be unique for a tree. So, you may be asked to construct a tree from inorder and postorder travarsal.

Try to think first before looking at the solution.

If look carefully for a while, you will find that root of a tree will always come at last in post order travarsal. We can use this property to split the tree into two subtrees. This is how we can construct the tree recursively by splitting...here post order travarsal will give us the root.

Also note that inorder and post order travarsals are also aligned. In inorder, the whole left subtree is travarsed, then root is travarsed and the whole right subtree is travarsed. On the otherhad, in postorder, the whole left subtree is travarsed, then whole right subtree is travarsed and then the root is travarsed. So, both travarsal are kinda alighned. So, you can split those arrays at the same time to produce subtrees.

I shoud note that problem can be asked to generate a tree from preorder and inorder travarsal. The solution is alsomost the same except in preorder, we will find the root at the beginning (instead at the end in case of postorder).

Another very important point!!!!: note that inorder and postorder array are not properly aligned. So, using index of one to caluclate index of the other will result wrong result. But, this problem can be solved using a simple technique. From the previous discussion, it is clear that the size of inorder and postorder array would be same as they corresponds to a subtree. Thus we can calculate how many elements are there in the left subtree. We can use that to calculate the index of the inorder and postorder arrays.

138. For instance, I have a n X k 2D array. I'm iterating them as:

for (i = 0; i < n; i++) {
  for (j = 0; j < k; j++) {

  }
}

Here, i corresponds n and j corresponds k. It may sound trivial, but it may seem confusing sometime. Inside the loops, we need to use i and j instead of n and k.. Also, you may use 'row' and 'col' instead of i and j.

139. Sometimes, in 2D array, you may create (n + 1) X (k + 1) array instead of n X k array. Instead of mapping an element to appropiate index by subtracting 1, we can use the element to map directly to the array element.

140. If needed, sometime, you can create min()/max() macro yourself, like #define max(a,b) (a < b ? b : a)

141. In egg-drop problem, we need to count what would the minimum number to steps needed for a given number of floors (n) and eggs (k). Note that, we don't need to find out the floor. If you needed to find the floor, we could do binary search like approach. But, here, the problem is different. We need to count the minimum number of steps, and counting minimum number of step through binary search like approach (checking the mid element first) may not need least amount of steps. In some cases, I found checking one-third-th element first will require fewer number of steps. So, here the equation is more complicated that binary search. We need to check for each floor to find the minimum # of steps.

Now, we need to write down the function that checks all the floor to find the minimum like:

https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/

Then peform DP instead of recursion.

Now, note that, do you really need to check for all the floors? 

https://leetcode.com/problems/super-egg-drop/solution/ 

The link shows you don't...

If you have two functions f1 and f2. f1 is always increasing and f2 is always decresing and you are taking the min of max of them (like the link), you can apply binary search like approach!!!! So, I guess, we are eventually using binary search, but not in the way I thought I would be....

\   /
 \ /
  /\
 /  \
/    \
f1   f2

142. Common variable names: i, j, k, m, n, row, col, res, tmp, ret, mid, hi, lo, start, end, count, cnt, res_cnt, num_col, num_row, mat, arr, s, ch, str, dp, stack, queue, s_idx, q_start, q_end, runner1, runner2, r1, r2, r1_nxt, r2_nxt, elem, left_idx, right_idx, parent_idx, list_head, num_bucket, backet, to_find, to_insert, adj_row, adj_col, ...... struct elem, struct node, struct cell, truct tuple, key, value, new_node, node, bucket, bucket_no, node_queue, len_queue, cur_node, cur_len, val, tweetId, userId, heap_len, cur_idx, max_idx, struct ListNode *slow, *fast; struct ListNode *slow_runner, *fast_runner, prefix_sum, suffix_sum, num_bits, L (for lengths), numerator (up), denominator (down), hi, lo, trie_insert(), trie_search(),  

struct followee* f;
struct tweet *t;

143.   char *str = "aabbcaad"; ..is fine..no need to do char str[] = {...};

144. Sometimes, you will need a data structure where we store count of each element. We extract an element with largest/smallest count from the data structure and decrement the count...Heap is a perfect data structure for this kinds of problems. For instance: reorganize-string problem.

145. Be careful, when you have '-' in a expression. For instance, in heap push_up(), we need the following expression:

  int parent_idx = (idx - 1) >> 1;

Now, we use this expression to calculate the parent index of a tree. Now, if idx == 0, then this logic is screwed. Even following logic is screwed too!

int parent_idx = (idx - 1) / 2;

We need to add an extra check before the expression. If idx == 0, then there is no parent... 

Note that, this creates a VERY hard to find bug..

146. May be I am reapeating, but don't try to create a 1D array to represent a 2D array. 2D array produces much cleaner code.

147. When checking if we can place a queen in two positions, I write the logic like:

return !(x1 == x2 || y1 == y2 || (x2 - x1) == (y2 - y1));  

But, it should be:

return !(x1 == x2 || y1 == y2 || abs (x2 - x1) == abs (y2 - y1));

Because, diagonal can be right-down and right-up.

148. If you need to check eqaulity of float or double, note that it would not work. For instance, in max-points-on-a-line, we need to create a map where key is the tangent of two points (y2-y1/x2-x1). To solve this precision problem, I should store y2-y1 and x2-x1 separately as int and use them as key.

Now, problem is how can I tell (3,4) and (6,8) are the same key? One apparent solution is to check if 6/3 == 8/4...But, note that this would not work for all the inputs. For instance, 6/3 == 9/4..

To solve the problem, we need to calculate GCD of 6 and 8 and divide the numbers by the GCD. That is, we will always store key as the reduced value like (2, 3) or (3,4) and so on.

149. Note that, you often need to create a list of something and check if an element already exists in the list. For instance, max-points-on-a-line problem. You can use map (balananced binary tree or binary tree) or hash to implement that. If there is an order between key, you can create a binary tree, I think.

Note that, to begin with, we can simply create a list.. and later change it to hash or map which is appropiate.

Note that, you will find much better performance with hash than binary tree. So, if you have an option to use hash or binary tree, go for hash (even though there are order among the numbers)!!!!!


150. Note that, list_insert should look like following:

void list_insert (struct value **head, int val)

Inside the function, you should use *head to use the head.

Orrrrr, you can do this:

struct value* list_insert (struct value *head, int val);

It will return new head!! I that case, you can use head directly and not use *head.

151. Suppose, you want to compare two numbers: x/y > a/b. Here all of them are int. This will not work. You should cast lhs and rhs to double.

152. In max-points-on-a-line problem, I may store tangent (y2-y1/x2-x1) as key as suggested in geeksforgeeks. But, note that tangent is not enough to check if some points are one a line. Specially tangent of two point pairs can be 0 or INFINITE and they may not be on the same line. Right question to ask here is how to check if three points are on the same line? In that case, we need to store 2 points. If we store (x1, y1) and (x2, y2), we can tell if another point is on the line. 

We do that by checking if x1 == x2, in that case we check if new point x == x1..Same for y axis. We also check following if x1 != x2 and y1 != y2:

(x - x1)/(x1 - x2) = (y - y1)/(y1 - y2).

153. Hot brownie helps to keep brain cool.

154. Sometimes, towards the end of the day, I look at a problem. It may seem quite tough. I try to come up with some solution on paper. The solution does not work. In the next moring, I start fresh. Look at the solution little differently. Now, the solution look easy. 

Moral: Sometimes it takes a fresh rethinking to solve a problem.

155. Sometimes, you may come across a problem where you need to check if you came through this path. This problem particularly arise in sequence building. In that, check if you can solve this using DFS/BFS. Usually you can. An example of such problem is longest-consecutive-sequence.

But, note that, when you really want to create a sequence, do you really need to start from the any node. For instance, in longest-consecutive-sequence problem, you are given an array. The first element of the array may not be the first element of the sequence. This is why, you may need to look both ways to create sequence. Solving this problem with DFS and BFS also involve havinhg visit array so that we don't visit an element if we visited before. But, all this problem can be simplified if we only start with elements that's the start of a sequence. In that case, we don't need to look bi-directionally. We only look unidirectionally. For instance, Approach #3

https://leetcode.com/problems/longest-consecutive-sequence/solution/  

156. struct node *hash[1000] = {NULL};

This is how you can initialize a hash or pointer array.

157. Note that, implementing hash should be pretty easy. And you have access to your hash function, so it's better than using C++ built-in hash!! :-)

158. When accessing hash, check if you element can be negative or not. If they can be negative, you need to make them positive.

159. When iterating a matrix, we can follow this paradigm:

  for (row = 0; row < num_row; row++) {
    for (col = 0; col < num_col; col++) {
      
    }
  }

Instead of

  for (i = 0; i < num_row; i++) {
    for (j = 0; j < num_col; j++) {
      
    }
  }

160. Sometimes, it's critical to choose where do we start DFS from. For instance, in pacific-atlantic-water-flow problem, it is natual to start doing DFS from nodes one by one if they are unvisited. But, this lead to visiting same node many times. But, if you think carefully, all the water goes to ocean. So, we can simply start DFS from ocean (nodes adjacent to ocean)

Note, that kind of problem (e.g. pacific-atlantic-water-flow) may appear to be solved  by a simple DP. But, if you look carefully, if you are using DP, you are not considering all the adjacent nodes (in all 4 directions). You are only considering 2 (left and up). So, it will not work.

161. Sometimes, in stack, you may not need to pop from the stack. You rather insert and modify the stack. For instance, longest-valid-parentheses problem.

162. "Window of substring of a string" == "substring of a string" == "window of a string". The wording can be confusing.

163. To check if a character is lower or upper case, there is a function: int islower(int c);

It returns non-zero if c is a lower case, it returns 0 if c is an uppercase.

164. There is no function to create a subtring from a string (index i to j). You can create your own:

  int res_len = min_end - min_start + 1;
  char *res = (char *) malloc ((res_len + 1) * sizeof (char));
  res[res_len] = '\0';
  memcpy (res, s + min_start, res_len * sizeof (char));
  return res;

Also note that, we don't need to use calloc to initialize all elements to 0.

165. Just for quickness sake, rememember that, to iterate all the elements of a string based on string length, you need to do this:

int len = strlen (s);
for (i = 0; i < len; i++) {

}

166. Sometimes, you may want to skip the beginning of an array. You may do that as:

  left = 0;
  while (!exist (hash, s[left])) {
    left++;
  }

Problem with this is you skip all the characters, so you will get segfault. So, it should be:

  left = 0;
  while (left < s_len && !exist (hash, s[left])) {
    left++;
  }

Anytime, you increase an index in a while loop or for loop (mostly happen in while loop in my case), be sure to check if the index is a valid index or not.

Note that, you also need to add following:

  if (left >= s_len)
    return "";

So, if left really exceeds array length, you want to write what you want to do.

167. We you have substring matching type problem (e.g. minimum-window-substring), you we perform sliding window type algorithm. There, we maintain two variables: left and right. Note that, sliding window algorithm is similar to KMP string matching algorithm (not 100% sure). 

The details of slinding window algorithm would be found at:

https://leetcode.com/problems/minimum-window-substring/solution/

Note that, in this algorithm, the left pointer should not reach to the end. If lengths of string s and t are s_len and t_len respectively, left pointer should go up to (s_len - t_len). If s_len goes till end, it will still work, but it will be highly inefficient specially if t_len is pretty high. 

Note that, implementation of slinding window can be treaky. You can implement it like:

  while (1) {
    //need to expand the right
    while (1) {
      if (right >= s_len)
        goto done;
      if (exist (hash, s[right])) {
        match_cnt++;
        if (match_cnt == t_len)
          break;
      }
      delete (hash, s[right]);
      right++;
    };
    //need to expand the left
    if (right - left + 1 < min_window_len) {
      min_window_len = right - left + 1;
      min_start = left;
      min_end = right;
    }
    insert (hash, s[left]);
    left++;
    match_cnt--;
    while (left <= s_len - t_len && get_value (hash, s[left]) < 0)
      left++;
    if (left > s_len - t_len)
      goto done;
    if (left > right) {
      right = left;
      break;
    }
  }  
done:
  if (min_start == -1) {
    return "";
  }

But, it becomes very messy. But, you can still think of it as substring matchig. So, your left visit from 0 to s_len - t_len. And then expand right internally. The above code can be implemented as:

  while (left <= s_len - t_len) {
    while (right < s_len && match_cnt < t_len) {
      if (get_value (hash, s[right]) > 0)
        match_cnt++;
      delete (hash, s[right]);
      right++;
    }
    if (match_cnt < t_len)
      break;
    while (get_value (hash, s[left]) < 0) {
      insert (hash, s[left]);
      left++;      
    }
    if (right - left < min_window_len) {
      min_window_len = right - left;
      min_start = left;
      min_end = right - 1;
    }
    insert (hash, s[left]);
    left++;
    match_cnt--;
  }

Note that, unconditional while can be simplified by moving internal breaking condition to condition.


168. Note, that we may need to keep track of minimmum window len, window start and window end (e.g. minimum-window-substring problem). We don't need to three variables to do that. But, I often use three variables. Instead, you can use start and min_window_len to do that.

169. Sometimes, it may seem that you need a copy of your hash function and modify that.. and in some point you need to create a fresh copy of the hash. For instance, minimum-window-substring problem. 

Now, think carefully, sometimes, it is possioble to use the hash so intellegently that you don't need a separate copy of the hash. You can modify the hash as you go..For instance, this is a solution to minimum-window-substring problem:

https://leetcode.com/problems/minimum-window-substring/discuss/1360317/Simple-c%2B%2B-solution-or-Sliding-Window-or-Hashmap-or-Explained-clearly-with-comments

 string minWindow(string s, string t) {
        // Initialize minl as INT_MAX
        int minl = INT_MAX;
        
        // Map to keep count of all characters of t 
        unordered_map <int, int> mp;
        for(auto ch: t) mp[ch]++;
        
        // Sliding Window Approach
        // Let c be the count of chars of t in a particular window. Initialize as 0
        // start be the start of the current window
        // end be the end of current window
        // minstart be the start for the minimum window found yet.
        
        int c = 0;
        
        int start = 0;
        int minstart = 0;
        
        for(int end = 0; end<s.length(); end++)
        {
            if(mp[s[end]]>0) c++;
            mp[s[end]]--; 
            
            // continue untill c equals length of t or when current window has all characters of t in it
            if(c==t.length())
            {
                // Note that negative values in map indicate the key char is not present in t, but present in s. And hence leading chars in s with negative values are insignificant.
                
                while(start<end && mp[s[start]]<0){
                    mp[s[start]]++;
                    start++;
                }
                
                if(end-start+1<minl)
                {
                    minl = end-start+1;
                    minstart = start;
                }
                
                // reduce the window size by incrementing start, reducing mp[s[start]] value, and reducing c
    
                mp[s[start]]++;
                start++;
                c--;
            }
        }
        
        if(minl==INT_MAX) return "";
        return s.substr(minstart, minl);


very important point!!!!!!
------------------------------
Note that, hash can keep track of what charater we need to look for in the sliding window. The hash also can keep track of what character we need to skip.

170. A very common mistake and hard to find bug!!!!

If you need to set array of characters where the array elemements are number (e.g. sudoku-solver). I often do:

board[i][j] = k;

But, I should have done:

board[i][j] = '0' + k;

171. Sometimes, in backtracking, there can more different types of return condition. For instance, in sudoku-solver, there are two return statements:

void solveSudoku_inner(char** board, int num_row, int num_col, int row, int col, bool *done)
{
  int i, j, k;
  
  for (i = 0; i < num_row; i++) {
    for (j = 0; j < num_col; j++) {
      if (board[i][j] != '.')
        continue;
      int hash[10] = {0};
      get_valid_values (board, num_row, num_col, i, j, hash);

      for (k = 1; k <= 9; k++) {
        if (!hash[k]) {
          board[i][j] = '0' + k;
          solveSudoku_inner (board, num_row, num_col, i, j, done);
          if (*done)
            return;
          board[i][j] = '.';
        }
      }
      ///Needed!!!! Coming here means we couldn't find appropiate value, so backtrack.
      return;
    }
  }
  //This return found a solution
  *done = true;
}

172. In heapify () or min_heap, name like parent_idx, left_idx, right_idx:

void push_down (int *arr, int len, int parent_idx)
{
  int left_idx = (parent_idx << 1) + 1, right_idx = (parent_idx << 1) + 2;
  ...
}

Also you need to keep track of min child. Check the left child first, then check the right right. Checking right child first makes things complicated, because right child may not exist...you know what, checking anyone at first is fine... but, checking left first ofcourse makes it easier!

Also, I forget to check "max_child_idx >=0" in following. This causes segfault!!!: 

  if (max_child_idx >=0 && arr[max_child_idx] > arr[parent_idx]) {
    tmp = arr[parent_idx];
    arr[parent_idx] = arr[max_child_idx];
    arr[max_child_idx] = tmp;
    push_down (arr, len, max_child_idx);
  }

173. How would you update an elemnement of a heap? One thing you can do (from my common sense, not sure if it's correct) is perform push_down() at that index assumeing that index is a parent. If the new number is larger than previous number, also perform push_down() for all the prior indices of the index. It's like we are creating the heap again. But, instead of starting from the very last parent, we start at the index where the value is updated.

This however would be very inefficient!!!!!

What you should do is:

If the new number is larger than before, perform push_down(). If the new number is smaller than before, perform push_up (). This is in min-heap.

Now, this is inefficient either!!!!!!!!!!

Note that, you update an heap at each iteration, you are using O(log n) everytime. Heap is more efficinet if you don't update heap in every iteration. For instance, take sliding-window-maximum problem as an example. It may seem that you should have a fixed size heap of size k. In every iteration, you should remove one element and add another element. Or you simply can update the ulemment. If you do that, you will get TLE because it's not so efficienet. 

What you should do instead is you should have a large heap and update size of the heap at runtime. In each iteration, you shoud add a new element. Then you should check if top of the heap is out of the window; if yes, remove it. In this approach, we also need to store index along with value. In this approach, we don't need to remove element at each iteration. 

Thus, if you need heap_update() , you should think if you really should do that. You should think if you can solve the problem such that you just need heap_add() and heap_delete()

174. Sometimes, you may need to create an struct object. The simplest syntax for that is:

  struct node n1, n2, n3, n4, n5, n6, n7, n8, n9, n10;
  n1 = (struct node) {1, &n2, &n3};

Note that, it is NOT (I often think so):

  struct node *n1, *n2, *n3;

Note that, it is also NOT (I often think so):

  n1 = (struct node) {.id = 1, .left = &n2, .right = &n3};

175. "stack buffer underflow" happens when you try to read to the left of an array. 

176. Sometimes, a data structure is needed for each iteration rather than all iteration. For instance, max-points-on-a-line problem require maintaining a hash where keys are tangent. But, note we can use tangent to tell if a point is one a line if one of the point is fixed. So, we will need a hash for each iteration. In other words, we need a hash for each point. Each hash will contain tangets of other points with respect to that point.

https://leetcode.com/problems/max-points-on-a-line/solution/

Sometimes, it does not seem clear with which respect we do something. In those situations, we can consider similar solution.

Also, note that, you may need to store counter per hash entry or a global counter. For instance, in max-points-on-a-line problem, you are considering one point at a time. Now the points can be as following:



          e
     d

a        b          c

Here, there are three points on the same line when considering point a. Note that, here, we need to store count per slope. If we use global cointer, the counter will wrongly return 5 instead of 3.

177. Sometimes, I use flag to store state. For instance, in find-median-from-data-stream problem, I tend to use a flag (enum) to store which heap the data was inserted last. But, if you think carefully, it's not needed. You can use heap's size to infer which heap was inserted last. I guess, similar approach can be used elsewhere. Any time you use a flag (enum) to store state, think again if you really need that.

Again, check if you really need a varuable? For instance, find-median-from-data-stream problem, you can have count, min_heap_cnt, and max_heap_cnt variable. But, if you think carefully, count = min_heap_cnt + max_heap_cnt.

Also, having a separete counter may save some operation during computation, it also means, you are maintaining an extra new state. Getting rif of that will certainly simplify the code.

178. In find-median-from-data-stream, you can define the data structure as following:

typedef struct {
  int *max_heap;
  int *min_heap;
  int max_heap_cnt;
  int min_heap_cnt;
} MedianFinder;

You can also declare it as following:

struct heap {
  int *arr;
  int count;
};

typedef struct {
  struct heap *max_heap;
  struct heap *min_heap;
} MedianFinder;


What are the pros and cons abount the above approaches?

Second approach is better for implementing generic heap functions. In first approach, client code has to keep track of the heap length. 

Buuuuuut, in first approach, we need fewer indirections. For instance, in second approach, we need to write code like "obj->min_heap.arr", ""obj->min_heap.count"" which seems ugly. So, writing code with fewer indirection definately produces cleaner code!!! Favor that!!!

In large projects, this problem can be fixed by writting simple macros to access the inner elements...

Now, we should use first approach which uses fewer indirection. But, with nice API, we can avoid clinent code having to do with increamenting max_heap_cnt, min_heap_cnt count..

For instance, 

void heap_add (struct elem *arr, int *len, int to_add)

Here, max_heap_cnt, min_heap_cnt would be passed as a reference and incremented internally.

179. In find-median-from-data-stream problem, we need to maintain two heaps. To decide, to which heap we add a new data, we check the size of both heaps. If the size of both heaps are the same, it's easy to decide where to add the new number. If the size of the two heaps are not the same, one heap has one more item than the other. In that case, it is not hard to decide to which heap the new data should be added. But, think about it. If one heap has 1 element and the other heap has 0 element, the heap with 0 element has random value at 0-th element. So, we should not compare that with the number to be added., We should compare the number_to_be_added with the first element of the heap with 1 element. Otherwise, it causes a bug.

180. Never under estimate the value of a long walk, clearing the head,... suddenly nice and clear solution comes to your mind!!!!!!

181. Writting code often takes around 30-45 minues (including bug fixes..). Clearing the head and coming up with a nearly good solution takes 1.5 hours...

182. To calculate sub-array sum (i.e. subarray-sum-equals-k problem), we cab do:

  for (i = 0; i < numsSize; i++) {
    sum = 0;
    for (j = i; j < numsSize; j++) {
      sum += nums[j];
      if (sum == k)
        count++;
    }
  }

We can also solve this issue with prefix sum as:

  for (i = 0; i < numsSize; i++) {
    if (prefix_sum[i] == k)
      count++;
    for (j = 0; j < i; j++) {
      if (prefix_sum[i] - prefix_sum[j] == k)
        count++;
    }
  }

Note that, they are not better than each other. Both are O (n^2)

Now, the prefix sum approach can be improved by using hashmap. We should store the prefix sum in hash map. Every time we insert a prefxi sum, we also should check if target - prefix_sum exists in the hashmap. Using that approach, we can solve the problem in O (n). For details, take a look at approach #4 at:

https://leetcode.com/problems/subarray-sum-equals-k/solution/ 

In other words, we need to find touples for which A_i - A_j == Target.

If store all As in a hash map, given a Target, We can find all the touples in O (n). (Very intersting!!!!!!!!)

Note that, here we need to store number of occurance of a prefix sum, otherwise it will not work. I tend to only store the prefix sum. But, without the number of occurance, we will get wrong result.

183. If you need to do topological sorting, try to use DFS to implement that. It is much to remember the actaul toplogical sorting algorithm. 

In the same way, if you need to use KMP string matching algorithm, use Sliding Window algorithm instead. It's easier that way.

184. When using DFS, think if the graph is connected. Connected graph means this a path among every nodes in the graph. If the graph is not connected, you can simply do that as following:

  for (j = 0; j < numCourses; j++) {
    if (visit[j])
      continue;
    //actual DFS
    start = j;
    s_idx = 0;
    stack[s_idx++] = start;
    while (s_idx) {
      cur = stack[s_idx - 1];
      if (visit[cur] == 2) {
        s_idx--;
        continue;
      }
  }

Note that, I tend to add another condition as folowing in the above code:

    if (visit[j] || indegree[j])
      continue;

But, this is not needed!!!!!!! We can start DFS at any node, it does not have to have an indegree of 0. Moreover, adding indegree to the logic will cause bug. The reason is, there may be a graph or connected subgraph which does not have a node with in-degree 0. We may want to start with any node in that case...... THis is a very important issue!!!!!!!!!!!

185. If you are asked separate stack/queue code from client code, you can create your own stack/queue struct and associated function. Like:

struct Queue {
  struct TreeNode* nodes[CAPACITY];
  int len[CAPACITY];
  int start;
  int end;
};

void queue_init (struct Queue *q)
{
  q->start = 0;
  q->end = 0;
}

void enqueue (struct Queue *q, struct TreeNode* n, int len)
{
  q->nodes[q->end] = n;
  q->len[q->end] = len;
  q->end++;
}

void dequeue (struct Queue *q, struct TreeNode** n, int *len)
{
  *n = q->nodes[q->start];
  *len = q->len[q->start];
  q->start++;
}

bool queue_empty (struct Queue *q)
{
  return q->end == q->start;
}

186. For hash, using #define CAPACITY 1000 is fine.

187. Define hash elements as following:

struct elem {
  int key; //use key ...
  int val;
  struct elem *next;
};

188. In hash, you can implemet:

bool exist (struct elem **hash, int key)

or 

struct elem* find (struct elem **hash, int key)

Think which one you need. I often found exist() is not enough and I need find().

189. You can also name the functions like:

hash_insert(), hash_find()...etc

190. If you need top k elements of n, it's more efficient to use heap instead of sorting because it would be klogn. If k is much smaller than n, it will be good!


191. You can implement heap interface as:


void construct_heap (struct elem **heap, int len);

struct elem* heap_pop_root (struct elem **heap, int *len)

Note that, in second function, you are passing the len as pointer. So, client code don't need to worry about maintaining the length.

192. When implementing hash, do:

 int bucket = abs (key) % CAPACITY;

I often forget abs() which cause problem if key is negative.

193. Suppose, you are supposed to design a twitter class (e.g. design-twitter problem). Your twitter class should have:

postTweet(int userId, int tweetId);

This means that, you are not designing TwitterUser class (I mistakenly thought I was). Both Tweet and TwitterUser classes are external. Here, we are going use those classes' ID to implement basic functionality. 

Note that, here we need to store mapping between user ID and followers/followees. We also need to store mapping between user ID and tweet IDs. We generally store these mapping in Database. But, here we are storing them in application.

194. If you are asked a design question, https://leetcode.com/problems/design-twitter/ is a good example..

195. Note that, we often use heap as a temporary data structure. So, we preallocate heap as an array. But, we also maintain a heap_len

196. You can implement heaps in two ways:

1. heap_delete and heap_construct(). Both of them will need push_down()
2. heap_delete() and heap_add(). heap_delete() will need push_down() whereas heap_add() will need push_up().

Choose one of the two ways depending on your need. Sometimes, you will construct the heap only once. And then only do heap_delete(). In that case, you can use process 1. But, if you need to perform head_add() run time (e.g. design-twitter problem), you can use process 2.

197. I often go ahead and use hash map where keys are elglish letter. You can simply use an array here!!

198. One common problem is: I often need to sort an array where array index means someething like key of a hash. But, when I sort the array, the index is messed up. How can I solve this problem?

One trivial way to solve this problem is to create a new array of type struct elem where elem is:

struct elem {
  int val;
  int index;
};

After sorting the array, we will still have our index. But, problem is it is very expensive. A better solution is described here:

https://stackoverflow.com/questions/4859261/get-the-indices-of-an-array-after-sorting

So, don't sort the original array at all. Create a new index array. Sort the index array. When sorting the index array, sort it based on the value of the original array. Like:

//global varuable so that it's accessible inside cmp
int hash[26] = {0};//int *hash; is fine as well

int cmp (const void *a, const void *b)
{
  return hash[*((int *)b)] - hash[*((int *)a)];
}


int func () 
{
  int indices[26];

  for (i = 0; i < 26; i++) {
    indices[i] = i;
  }
  
  qsort (indices, 26, sizeof (int), cmp);

  for (i = 0; i < 26; i++) {
    //now access this way.....
    if (!hash[indices[i]])

  }
}
  

199. If you use global variable, you must initialize it inside function. Otherwise, it will give you wrong value from the function. For instance, in the above code, you should do following in the func():

memset (hash, 0, 26 * sizeof (int));


200. In heap_delete(), we do:

heap[0] = heap[*heap_len - 1];

Note that, if *heap_len == 0, it will crash. So, anytime, you do 'minus' in array index, think if it will ever be negative. If yes, handle the situation separately. Like:

  if (!(*heap_len))
    return;

201. Sometimes, you may need to sort an input array. But, sometimes, you may need to keep your input array in sorted manner and update it (for inatance, task-scheduler). Sorting the array will not cut it. For instance, you max need to extract the largest number, update it's frequency and insert it back in every iteration. We can use heap to solve this problem...

In this, I may wonder when should I delete and insert to heap. For instance, in task-scheduler problem, we can delete and insert it back in every iteration. But, if we get same character in two consecutive iteration, we cannot place them side by side. Intelligent thing is to delete it in every iteration, but after passing n iteration, insert it back. That way we don't need to worry about getting same characters in the consecutive iteration. 

202. Sometimes, you input a 2D array (e.g. minesweeper problem). You are asked to return a 2D array. This does not mean you need to create a new array (although you could). You can simply update the input array and return it. 

It's like in list_insert(), when we input a list_head and return a list head. We don't want to update the input. Rather we want to return the head. This creates cleaner API. In order to update input, we need to pass pointer to the head instead of head and then use "*head" everytime you want to use head. This is not very clean.

203. I may be tempting to write all the logic in a function. But, don't do it. Write a separate function. This is more professional, produces clean code, 

204. When doing DFS recursively or visiting all the adjacent cells recersively, I forget that I will need visit array to keep tracking of wheather I visited a cell or not.

205. If you are asked to sort a linked list, first thing to ask is to what is the desired runtime? If O(n^2) is acceptable, bubble sort can be implemented pretty easily. Here, we don't need to manipulate pointers (I suppose) and just swap the value. If we use insertion sort, note that we can't do random access in linked list, so we will few pointer manipulation in insertion sort.

Now, if O(nlogn) is expected, we can do quick sort and merge sort. The worst case time of quick sort is O(n^2), but average case runtime is O(nlogn). On the otherhand, merge sort is really O(nlogn). Implementing quick sort on linked list can be pretty tricky, but merge sort is easier... Take a look at both top-down and bottom-up approaches. I like bottom up approach because it does not need recursion (extra space), and more logical. I remember, I often use to wonder why do we implement merge sort the way we do. It's more natural to implement it in bottom-up fashion. 

https://leetcode.com/problems/sort-list/solution/


Now, if you look carefully, bottom-up implementation is much harder than top-down because you need to group every 1, 2, 4, 8,...elements. In top-down approach, we don't need to worry about that. We can simply write generic logic to split and merge.... So, this is why top-down is preferable.. 

Now, how would you implement top-down merge sort? One solution is to send head and tail of a linked list. Then find the middle. The perfor merge sort as:

struct ListNode* merge_sort(struct ListNode *head, struct ListNode *tail)
{
  struct ListNode *mid;
  
  if (head == tail)
    return head;
  
  mid = get_mid (head, tail);
  merge_sort (head, mid);
  merge_sort (mid->next, tail);

  //merge based on the heads and tails returned from the above function 
}

Note that this is just a psudocode. We need to return both head and tail from merge_sort function so that we can merge them appropiately. Implementing this is obviaously a night-mare!!! Can we simplify this? Can we implement it such that we don't need to maintain tail? 

One way we can do is, when get mid, we really set mid->next = NULL. That is, we literally split the linked list into two two linked lists. THis simplifies the logic enoumously!!!!!!!!!!!!!!!!!!!!!

Now, we don't need to keep track of end!!!!


Keep in mind that, merging is the most critical code of merge sort, rest of the code is easy..so don't over think it :)


205. Sometimes, a problem look simple. For instance, kth-smallest-element-in-a-sorted-matrix problem, it may appears that we use simple division and modulous to find the appropiate index. It will indeed work if all the numbers are distinct.

But, there are many same numbers, the simple approach will not work. But, in that case, the problem can be solved by keeping track of the visited list, candidate list, and unvisited list (we can have a separate state matrix and store 0, 1, 2 to do that). In every iteration we extract the minimum. And then we add few more elemenent which are candidates.

Note that, this approach will be very expensive as we will need O(n^2) to find the minimum at every step.

We can improve the solution by using a heap. 

The problem can also be viewed as finding k-th element in n sorted list as suggested in:

https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/

Thus, the problem become very similar to merging n sorted list.

Don't forget that if you need to find min/max among a dynamic list, you should use heap!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

206. For instance, you are asked to delete all the consecutive elements of a list where their sum equl to 0. We can maintain prefix sum and store it in a hash. If a prefix sum is previously seen, then we know that elements since then to now equal 0....

Now, there is a catch. If prefix sum is 0, then all the elements from the beginning till now equal 0 (I often forget this). Note that, with this algorithm, you don't even need to worry about treating elements with 0.

This is a very important observation!!!!

207. Sometimes, you need to do sequential search to find maximum of something (e.g. maximum-xor-of-two-numbers-in-an-array or lingest prefix match). Here, sequential search will be very expensive because it may contain millions of entries. To increase the search speed, we often use binary tree (map) or hash. Note that, we really can not use binary tree or hash, becuase here we are not really searching anyting. We are rather testing elery element. We need to test elements in a way that we don't need to test all the elelements. And that's how we increase the efficiency!!!!!! So, how can we reperent the input that we don't need to test all inputs. Ratther we can can consider some and skip the rest...?

Two ways to achieve those is Trie !!!!!!! (very important!!)

https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/

Take a look at bitwise tree approach here!!!!

208. What is the number of digits needed for an integer? I often think of this problem as two groups: 1. numbers that are multiples of 10 and numbers that are not multiples of 10s.

So, I tend to write the logic as:

n % 10 == 0 ? log10(n) + 1 : cell (log10(n)). 

But, it is overly complicated!!! Think carefully...you can write the logic as:

num_digits = log10(n) + 1.

This will work for all the cases!!!! Note that, the logic is same for 10-99..


In the same way, what is the number of bits needed for a number?

num_bits = log2(n) + 1;


209. For instance, you have many numbers. What is the minimum number of bits needed to represent all the numbers? 

It is the number of bits needed for the maximum number of the input numbers....This is very obvious. But, it does not come to mind natuarally when come across in a problem like maximum-xor-of-two-numbers-in-an-array problem.

210. What is the runtime of Trie lookup? It's the height of the trie. For instance, in maximum-xor-of-two-numbers-in-an-array problem, the height of the trie is L where L is the number of bits. In this case, runtime will be O(L). Note that, you may visit more than one branch of a trie (for instance, maximum-xor-of-two-numbers-in-an-array problem). In this case, the runtime is O(n) because we may end up visiting all the nodes. But, not more than n..


Added later
----------------
Actually previous discussion was wrong!!!! Lookup in Trie is O(L) in other words O(1). Now, note that you cannot find the maximum-xor-of-two-numbers-in-an-array in one Trie iteration. I often try to do that mistakenly. I use two pointers. But, I notice that in 3rd level, I will need 4 pointers, in 4th level, I will need 8 pointers, and so on....so, clearly it's not the right way.

What we need to do is, we need to perform search for each number at a time. For each number, we need to find the number that results maximum XOR. That is, we need to perform trie lookup n time. That's why, lookup time is O(n).

211. if (ret ^ nums[i] > max) will return wrong result!!!! It should be:


if ((ret ^ nums[i]) > max)

212. For instance, you are asked to return a string from a function (e.g. fraction-to-recurring-decimal). I mistakenly allocate the string statically, fill it up with sprintf() and return it. It will not work because the string will be disallocated!!! It is very trivial, but I make the mkistake.

213. sprintf (ret, "%s(%s)", res, fraction); is fine. We don't need \( \)... but, I remain confused if I need it or not

214. For instance, in fraction-to-recurring-decimal problem, I can input:

2       4
-- ,   -----
5       333

In each step, if nominator is smaller than denominator, I add 0 till it's smaller than denominator, then I do the actual division. Problem with this approach is I am trying to do two things at the same time. What I can do is, in each step, if nominator is smaller than denominator, then add 0; otherwise calculate the division. This simplifies the logic enourmously!!!! So, in a step, if you need to do some preprocessing before performing the actual task, think if you can simplify this. If you can generalize the preprocessing with actaul task, you write generic logic. 

215. I got following error with int a = abs (b);

"negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself"

To fix the problem, do this:

long a = labs (b); prototype of labs is : long int labs(long int x)

This is very important!!!

216. In maximum-product-subarray, we you can simply use bruteforce solution which would be O(n^2). Note that, if you use DP where you calculate product of subarray of length 1, 2, 3,...it will also be O(n^2). However, aparently there is a better DP solution that can achive O(n) which is very similar to "Largest Sum Contiguous Subarray". So, it's worth taking note!!

This problem can be solved in O(n). First take a look at maximum-subarray problem. Think if you can solve maximum-subarray or maximum-product-subarray in O(n). If not, double check the solutions...

Note that they are not DP.

217. It's worth reiterating that min() and max () are not built-in function in C. If needed make your own function or macro.

218. Sometimes, I over think. For instance, longest-increasing-subsequence problem, I can solve by counting how many smaller elements to the left. This is O(n^2). I don't think of this as DP. It comes natually to me. But, they (leetcode/geekforgeek) solve in the same way, call it DP and their solution is also O(n^2). So, I guess, if you are given similar prtoblem, you you find O(n^2) solution, double check if the solution is acceptable or not. In many cases, even in leetcode, the solution is accepatbale...

219. Sometimes, you want to stop searching in a recursive function if you found the target. For instance, lowest-common-ancestor-of-a-binary-tree problem. These can be solved by creating a new function where result is passed as a pointer and set it. The function will return if the result is already set. Note that, doing this at the beginning of the function is not enough. You also need to do it after calling the recursive function as:

//Create an inner function that sets result (in this case lca).
struct TreeNode* LCA_inner(struct TreeNode* root, struct TreeNode* p, 
               struct TreeNode* q, struct TreeNode** lca)
{
    struct TreeNode *res = NULL, *res1 = NULL, *res2 = NULL; 
  
    if (!root)
      return NULL;
  
    //First place where if lca is set, return  (not really needed, will explain later)
    if (*lca)
      return root;
  
    if (root == p || root == q) {
      res = LCA_inner (root->left, p, q, lca);
      if (res) {
        *lca = root;
        return root;
      }
      res = LCA_inner (root->right, p, q, lca);
      if (res) {
        *lca = root;
        return root;
      }
      return root;
    }
    
    res1 = LCA_inner (root->left, p, q, lca);
    res2 = LCA_inner (root->right, p, q, lca);
  
    //We also need to check lca again in the second time if lca is set; if yes, return. This is because both recursive function may have been called but not processed the result..
    if (*lca)
      return root;
  
    if (res1 && res2) {
      *lca = root;
      return root;
    }
  
    return res1 ? res1 : res2;
}

added later
---------------------

Now, if you think carefully, you don't need the first:

    if (*lca)
      return root;

This is because once you find the result, you don't go ahead. But, you need second one because after you have found the result, you want to ignore the result. That why, the ignoring logic should be put after the recursion call, not at the beginning of the function (unlike usual recursion)

220. longest-repeating-character-replacement sounds a serious problem!!!! Here, we need to find out the longest repeating sequence after allowing certain number of replacement. At the beginning, I view the problem as finding longest repeating sequence for each distinct characters in the string.


Thus the problem can be viewed as, finding longest sequence in a string like AA--A-A-A-

This problem can be further simplified by finding longest sequnce in 1100101010.

The problem can be further simpified by 2, [2], 1, [1], 1, [1], 1. Here, we ignored the last 0. The  we get the numbers but counting the running count of consecutive 1 or 0. We put [] in around the running count of 0. THat means, we need to fill up those postion up to k times.

We can represent these as a linked list and update the linked list based on k. That's how, we will get the maximum consecutive sequence.


This is how we solve the problem in traditional way!!!!


Now, this is hugely inefficient!!!! Note that, here we need to find a sequnce of characters...can we use sliding window algorithm here???

Here, we can maintain a sliding window where the number of non-max elemets are up to k instances. That's how we can maintain a sliding window as:

https://leetcode.com/problems/longest-repeating-character-replacement/discuss/91271/Java-12-lines-O%28n%29-sliding-window-solution-with-explanation/137008


Also, in sliding window, you should maintain left and right index. Someone may call it two pointers approach ;-)


221. Note that, length of sliding window = right -left + 1

222. Sometimes, we need to keep track of max occurance of a character in a sliding window. We can use hash for that. For instance, in longest-repeating-character-replacement, we can have:

int hash[26] = {0};

When we increase the window, we do this:

right++;
hash[s[right]-'a']++;

When we increase shirink the woindow (i.e. increase the left), we do:

hash[s[left]-'a']--;
left++;

This is how, we can use a hash to keep track of the counts of characters in a sliding window.

If we need max of the count, we simply can write a for loop to get the max. If the length of sliding window is small or the length of hash is samll or fixed, we write a for loop. If you are really crazy about performance or if the list is very long, we can use heap to keep track of the maximum element..

223. Finally, a sliding window can be implemented as:

while (left < len && right < len) {

}

Note that, we increase both right and left in sliding window algoritthm. Here, formar is the window expanding and the later is the window shirinking.
So, we need to check both left and right if they have reached the end.

224. For instance, in https://leetcode.com/problems/find-k-closest-elements/. This problem has an unusual solution. You can sort this based on a number "x". Note that, when we do sorting, we sort all the numbers with respect to 0. Sorting can be viewed as sorting each number based on their distance from 0. Now, in this problem, you can sort all the numbers based on their distance from "x". 

This is not a good solution though because it takes O(nlogn). There is a better solution and which often come to mind. But, I am mentioning this so that we can view sorting in a different way.

Now, let's take a look at more obvious solution and more efficient solution: binary search + sliding window.

Note that, sliding window does not often go left to right. It may start from the middle, and grow to the left and right based the numbers. We will still need "left" and "right", but we don't need "while (left < len && right < len)" in this case.

Also, note that, we cannot apply binary search directly here!! If all the numbers are sorted based on the distance from "x", then we could. But, here, the numbers are sorted in ordinary manner. Now, we need to modify the logic slightly such that it still finds the number with smallest distance from "x". Note that, the distance may not be 0.

As the numbers are sorted, we can still use traditional binary search logic as following:

    if (x > arr[mid]) {
      start = mid + 1;
      if (less_than (x, arr[mid], arr[start]))
        return mid;
    } else {
      end = mid - 1;
      if (less_than (x, arr[mid], arr[end]))
        return mid;
    }

But, note that, plain binary search logic is not sufficient. It is suffficient in case "mid" is not pointing the target value. But, if "mid" is pointing to the right value and as distance is not 0, we may mistakenly skip and go to left or right. In this case, we need to check if the distance of left or right with mid. If distance of mid is smaller, then mid is the right position.

224. For instance, you want to initalize all elements of an array to -1. You do this:

int start[26] = {-1};

This will initialize like -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.....

Note that, array initalization like that will only work for 0. If you want to initialize with non-zero, you need to do that manually!!!!!!

I knew this, but I forgot! and I forget!!

225. For instance, you need to use a global array in your cmp as:

int *end_g;

int cmp (const void *a, const void *b)
{
  return end_g[*((int *)a)] - end_g[*((int *)b)];
}

You can do it in two ways: 

end_g = (int *) malloc ()....
qsort (..);

Or you can do it as :

int end[26];
..
..
end_g = end;
qsort (..);

That is, you can just use the global variable to point it to the right place. The global variable does not necessarily be allocated...

226. In partition-labels, you need to merge intervals. How would you merge intervals?

One way is projection. You project the intervals on to an array. But, that approach does not work here, because we don't want to merge:

a: 5 - 7 and b:8 - 10.

But, the way projection  works, it will merge the two intervals. But, the two intervals should not be merged in this context. If the interval should be merged, then projection can be used.

Another approach is to sort the intervals based on the end_time. But, that is not a right approach at al!!!!!!! For instance, iterating based on end_time will not work for following case. It two create two intervals:

   ---  ---

The right approach is sort the intervals based on start_time. Merging them in this way is the right way to go!!!!


227. Never forget to take some time to write an input on paper and think about the algorithm. It's almost impossible to come up with an algorithm from the the problem statement!!
---------------


228. In sqrtx problem, I think like this. I will start with 1. Then, if this is not it, then I will double the number in each iteration. like:

1, 2, 4, 8, 16...

Once I exceed to the number, this means the the target numnber is between n and n/2 where n is the current number. Now, we can perform binary search between n/2 and n.

But, to simplify this, we can implement binary search from the very beginning. In fact, that is the right approach.

Note that, in binary search, the condition should be:

  while (start <= end) {

  }

Not:

  while (start < end) {

  }

But, based on the problem, you may need to use the second one...

229. In problem escription, if something is bold, take a note..usually it's important. For instance, in logger-rate-limiter problem, logger message are unique. I would not think so at the beginning. So, if a problem is not well under stood, best way to understand is always look at the examples. Don't worry about description too much (i.e. being bold). This is actually totally contradictatory to what I said in the first line of this paragraph. Yes, rely on example, not the problem description. You need to play with the example anyway when implementing something.


230. Remember that if you use "char *" as key in your hash, in insert(), you need to use "strcmp()" to check if the key exists or not. Sometimes, I use existing code for my use and the code will compile but would not work because that needs to be changed. 

Again, to calculate hash for "char *", you can simply sum up the ASCII code of all the characters and mod by CAPACITY.

231. To convert case, there are functions like:

int toupper (int c); 
int tolower(int c);

Note that, thet are NOT: to_upper() or upper(). I often confuse with these.

232. If you are asked to convert a number to 7 base number, not that it's similar to convert a number to binary (i.e. in each each iteration divide by 2 and mod by 2....)

Like other base, the number of digits needed is log_7(num) + 1.

Note that, you can calculate log_7(num) = log10(num)/log10(7). 

Also note that, if the numnber is negative, you should make it positive and process uniformly..


233. In BST, left subtree will contain elements that are less than or (equal) to root! Equal elements will not be in the right sub tree.

234. "Mode" is not "median". "Mode" means the most frequent items of an array. An array can have more than one mode.

235. Take a look atthe problem find-mode-in-binary-search-tree. It may be tempting to implement it using a hash. You can travarse the tree, check if a node already exist, if yes, increase the count. I tend to follow this approach because of the following structure:


                 20
                /  \
               2   40
              / \  /
             1  20 30

That, is the same elements may not be in the tree consecutively. So, apparently there is no way to get the same element consecutively. Oh, no!!!!! There is !!!!!!!!!!!!! BST tree is awaesome because there is a way to get the elements consecutively even though they are not present in a tree consecutively. Remember that, you can travarase a tree in inorder travarsal, you get a sorted array. In other words, you get the number consecutively. So, the idea is travarse the nodes consecutively. Count their frequncy. ....


236. Sometimes, I need to keep state in a recursive function. What I do is, I allocate the variables in the main function and pass those variables as a reference and update them inside function. This however is not nice. It creates ugly function interface. And you need to derefernce the variable to use it which is ugly as well. For intance:

void inorder (struct TreeNode *root, int *res, int *res_cnt, int *prev, int *count, int *max)
{
  if (!root)
    return;
  inorder (root->left, res, res_cnt);
  if (root->val == *prev) {
    *count++;
  } else {
    prev = root->val;
    *count = 1;
  }
  if (*count > *max) {
    *max = *count;
    res[0] = root->val;
    *res_cnt = 1;
  } else if (count == max) {
    res[*res_cnt] = root->val;
    *res_cnt += 1;
  }
  inorder (root->right, res, res_cnt);
}


What you should do is, you should implement them using a global variable:

//global variable
int prev, count, max;

void inorder (struct TreeNode *root, int *res, int *res_cnt)
{
  if (!root)
    return;
  inorder (root->left, res, res_cnt);
  if (root->val == prev) {
    count++;
  } else {
    prev = root->val;
    count = 1;
  }
  if (count > max) {
    max = count;
    res[0] = root->val;
    *res_cnt = 1;
  } else if (count == max) {
    res[*res_cnt] = root->val;
    *res_cnt += 1;
  }
  inorder (root->right, res, res_cnt);
}

int* findMode(struct TreeNode* root, int* returnSize){
  int *res = (int *) malloc (10000 * sizeof (int));
  int res_cnt = 0;
  
  //global variables are initialized
  prev = 100001;
  count = 0; 
  max = 0;
  inorder (root, res, &res_cnt);
  *returnSize = res_cnt;
  return res;
}


Note that, the global variables are initialized before the function  call. You need to do it before every function call. Otherwise, you will get undefined behaviour. Sometimes, what I do is, I initialize the global variable in declaration, like

int prev = 10000001, count = 0, max = 0;

And I don't initalize before function call. This will work for 1 time. But, it will not work for subsequent callls.

237. In is-subsequence problem, it's not an easy one. The problem can be solved in several ways. 

First, you can create a hash-set based on characters. You will store the indices the character occurred. Then, you can iterarate over the subsequnce array. When you find a character, if the next character is a following index, you can go further. Note that, you may need to backtrack sometimes.

This types of problems can be solved using recursion or sliding window!!!!!! Sliding window often performs much better than recursion.

For instance, your inputs are "abcad" and "acd". When you find a match of the first character, you can make recursive call of ("bcad", "cd").

Again, this problem can be thought of two sliding window match..


Thus, these sorts of problem can be implemented using recursion or sliding window......!!!!!!!!!!!


Also, note that, in sliding window, may need manual step to initialize the sliding window. For instance, in the following code, we find the first character to initialize the sliding window. You also may need the another manual step to re-initialize the sliding window within the algorithm.


bool isSubsequence(char * s, char * t){
  int s_start = 0, s_end, s_len = strlen (s), 
    t_len = strlen (t), t_start = 0, t_end = 0;
  
  if (!s[0])
    return true;
  
  //manually setting the sliding window
  while (t_start < t_len && t[t_start] != s[0])
    t_start++;
  if (t_start == t_len)
    return false;
  t_end = t_start;
  s_start = 0;
  s_end = 0;
  
  while (s_end + 1 < s_len) {
    //re-initialize the sliding window
    if (t_end + 1 == t_len) {
      t_start++;
      while (t_start < t_len && t[t_start] != s[0])
        t_start++;
      if (t_start == t_len)
        return false;
      t_end = t_start;
      s_start = 0;
      s_end = 0;
      continue;
    }
    if (s[s_end + 1] == t[t_end+1]) {
      s_end++;
    }
    t_end++;
  }
  return true;
}


238. To find a char in a string, use "char *strchr(const char *str, int c)". Note that, it is NOT "strch()" (I often think so).

Also, strchr () returns NULL if the char is not found. I often think it returns -1.

Note that, it also returns "char *", not "int".

plus_idx

239. For instance, you have an integer that represents minutes. It should take 2 characters. That is, intstead of saying "1:2" (1 hour 2 minutes), it should say "1:02". How can you achieve that?

You can use %02d. For instance:

sprintf (str, "%d:%02d", hour_, min_);

Here, I am saying that minutes should consume at least 2 characters (can take more (i.e. 3, 4) characters). If it takes less than 2 characters, it should be made two characters by padding '0'.

240. It may seem that you can also implement a backtracking algorithm with nested loop. For instance, if you are given a string, and you need to find all the combination of two characters from the string, you can write it using two nested loop. You don't need backtracking for that. If you need to write combination of every three characters, you can write using three nested loop. But, if you need all possible combination, you will need backtracking. Nested for loop will not work....

When backtracking, you should also note if you are generating permutation or combination. Note that, nested for loop creates combination, it does not create permution. If you generate permutation using nested loop, you need to shuffle elements among them to create new permutation.

So, if need permutation or you need combination with any length, you should use backtracking. Nested for loop will only can be used to generate fixed-length combination.

Now, for instance, take a look at binary-watch problem. You obviously need backtracking becuase length of permutation/combination is not fixed.

You can have two arrays to set state:

int hour[4];
int min[6];

void backtrack (int num, char **res, int *res_cnt)
{
  int i, hour_, min_;
  char *str = (char *) calloc (6, sizeof (char));
  //printf ("backtrack %d \n", num);
  
  if (!num) {
    hour_ = get_hour ();
    min_ = get_min ();
    sprintf (str, "%d:%02d", hour_, min_);
    res[(*res_cnt)++] = str;
    return;
  }

  for (i = 0; i < 4; i++) {
    if (hour[i])
      continue;
    hour[i] = 1;
    if (valid ())
      backtrack (num - 1, res, res_cnt);
    hour[i] = 0;
  }
  for (i = 0; i < 6; i++) {
    if (min[i])
      continue;
    min[i] = 1;
    if (valid ())
      backtrack (num - 1, res, res_cnt);
    min[i] = 0;
  }
}

Problem with this would be: it will generate same time twice despite continuing if the the certain array element being '1'. Why is that?

For instance, 'hour' is : 0 0 1 0.

Now, if we call backtrack(), it will generate '0 0 1 1' again which was previously produced. To solve this problem, we shoud start from where we ended last time (like we do in nested loop solution). So, the pronblem can be re-written as:

void backtrack (int num, int min_start, int hour_start, char **res, int *res_cnt)
{
  int i, hour_, min_;
  char *str = (char *) calloc (6, sizeof (char));
  //printf ("backtrack %d \n", num);
  
  if (!num) {
    hour_ = get_hour ();
    min_ = get_min ();
    sprintf (str, "%d:%02d", hour_, min_);
    res[(*res_cnt)++] = str;
    return;
  }

  for (i = hour_start; i < 4; i++) {
    hour[i] = 1;
    if (valid ())
      backtrack (num - 1, min_start, i + 1, res, res_cnt);
    hour[i] = 0;
  }
  for (i = min_start; i < 6; i++) {
    min[i] = 1;
    if (valid ())
      backtrack (num - 1, i + 1, hour_start, res, res_cnt);
    min[i] = 0;
  }
}

This will avoid generating duplocates. Note that, we may need to use similar logic as nested-loop (that is , we may need to keep track of how far we have generated...instead of starting from the beginning everytime)



Finally, the above code will have another issue. It will perform backtracking separately on hour and minutes. This will produce duplicate output. To solve this problem, we need to merge hour and minute array so that we only perform backtracking on a single array...this should solve the duplicate problem. The solution should be like:

int led[10];

void backtrack (int num, int start, char **res, int *res_cnt)
{
  int i, hour_, min_;
  char *str = (char *) calloc (6, sizeof (char));
  //printf ("backtrack %d \n", num);
  
  if (!num) {
    hour_ = get_hour ();
    min_ = get_min ();
    sprintf (str, "%d:%02d", hour_, min_);
    res[(*res_cnt)++] = str;
    return;
  }

  for (i = start; i < 10; i++) {
    led[i] = 1;
    if (valid ())
      backtrack (num - 1, i + 1, res, res_cnt);
    led[i] = 0;
  }
}


241. Sometimes, a problem may look like int to binary conversation. For instance, excel-sheet-column-title problem. This problem seem like decimal to mod-26 conversation. But there is a difference. For instance,

52 = AZ

That, 52 is broken as (1 * 26 + 26), not (2 * 26 + 0)

Thus, adter doing mod by 26, if the result is 0, we need to break it into a * 26 + 26 manner as following:

  i = num_digit - 1;
  while (columnNumber) {
    rem = columnNumber % 26;
    columnNumber /= 26;
    if (!rem) {
      rem = 26;
      columnNumber--;
    }
    res[i--] = ((rem - 1) % 26) + 'A';
  }
  
  return &res[i+1];

Note that, here we are filling the array from the end. We could also fill the array from front and reverse the array later. But, that is not really necessary. 

Also, note how we are returning the beginning of the array. We cannot simply return "res" because we may not fill up the array.

242. Sometimes, rounded array can be very simple. You can just find the next index by "idx % size"; For instance: moving-average-from-data-stream problem.

243. Like checking if two interval overlapps or not, checking if two rectangle overlaps or not is also a tough problem (rectangle-overlap problem).

I try to solve this problem by checking if any one point of a rectangle fall within the other rectangle. But, this will not work for:

[7,8,13,15]
[10,8,12,20]

They overlap but, there is no such point.

Now, try to solve the problem in the way we solved interval overlapping. Instead of checking "if they overlap", check "if they don't overlap". That is, for each each point of a rectangle, check if the point is outside of the rectangle. Now, you will be surprised, this will not work for the above input either. It will tell you that some points are outside of the rectangle while they are not. 

Moral of the story is, checking by point to check a rectangle is not a good idea. Point cannot capture the whole rectangle. For interval, two points can capture an interval, but checking each point individually for rectangle is not a good idea.

Another solution is to, check any line of a rectangle insersects with any line of the other rectangle. Now, checking if two line intersects or not is not trivial. But, there was a trivial solution on our nose that we couldn't find. 

https://leetcode.com/problems/rectangle-overlap/solution/

Check both solutions.

Note that, it is easy to check if another rectangle is to the right/left/up/down of another rectangle. But, checking other thing isn't easy.

244. Note that, a lot of tree problems can be solved using recursion on left and right subtree (like height calculation). So, instead of checking preorder, postorder, inorder first, check if a problem can be solved using recursion on left and right subtree.

255. Sometimes, you may need to check if two trees are same (as in subtree-of-another-tree problem). We know that inorder/preorder/postorder is not unique for a tree. That is, there can be two different trees that have same inorder/preorder/postorder. But, inorder+preorder or inorder+postorder are unique for a tree. But, think about it. There is a better solution to check if two trees are same. You can simply perform recursion on left and right subtree.

256. following expression is fine:

if (a * b > c * d)

You don't need to do:

if ((a * b) > (c * d))

That is needed only for bitwise operator I guess.

257. maximum-product-of-three-numbers is a very interesting problem. I try to solve this problem as following:

I sort the number. Then I do:

if (nums[numsSize - 1] * nums[numsSize - 2] > nums[0] * nums[1])
  return nums[numsSize - 1] * nums[numsSize - 2] * nums[numsSize - 3];
else
  nums[0] * nums[1] * nums[numsSize - 1];

The rational is as following: I need to find largest product of three numbers. So, I try to find the largest product of two numbers first. And then I try to find the largest of three. The largest of two would be found at the beginning or at the end. Once I find the largest product of two, I find the largest product of three. This can work for following input:

-5 -3 -1 0 3 4 5 6

BUT, this solution is not right. Finding sum of three based on the sum of two can be misleading. For instance, the above algorithm will not work for following input:

-8 -7 -2 10 20

Here, candidate maximum sum of two is: 56 and 200.

If we choose 200, it will result sum of three = -400. But, actaul results should be : -8 * -7 * 20.

The real solution is a lot easier than we think. For instance, we know that solution would be either:

nums[numsSize - 3] * nums[numsSize - 2] * nums[numsSize - 1]

or 

nums[0] * nums[1] * nums[numsSize - 1]

So, why don't we calculate that and get the maximum. We don't need to break it into product of two!!!!

Moral of the solution: Sometimes it is easier to compare the potential candidates instead of breaking the problem into smaller problems.


Note that, this solution also works for inputs like:

-5 -4 -3 -2 -1

Here, we need to  the absolute value of the result show be minimum, not maximium. As we find the cadidates directly, this solution still works.


258. It's OK to create a stack with a fixed array. For instance: https://leetcode.com/problems/max-stack/
 
259. Take a look at max-stack problem. Implementing stack is easy. Implementing a stack where you can max() in constant time is also easy. You can do it in two ways:

a. Maintain another array where we store index to the next maximum elemment. That way, if we pop the maximum element, we can get the index to the next maximum element from that array.

b. Another strategy is to maintain another array where we keep track of the current maximum. For instance, if we add [2, 1, 5, 3, 9], we'll remember [2, 2, 5, 5, 9].

Now problem is, how to support pop_max()? Note that, this problem may look simple at the beginning. I thought that I would use approach a. Then when I do pop_max(), I simply invalidate the index. We can have another array "valid" that keeps track if an element of the stack is valid or not. But, this approach would not work. That's because when you do pop_max(), next biggiest element may not be as we recorded. The next biggest element may have been added after the current max. So, the index to the next maximim element is not actually right.

One way to solve this problem is, every time we insert a new element, we find an element which is larger than the element to insert, but next element to the larger is smaller than the element to insert...

This is one way. But, this may require each push() extra processing which is not desirable.

So, in order words, it is not possible to implememt a stack that has pop_max() and all the functions are O(1).

Now, we can use trivial approach. We can keep rest of the function as it is. But, for pop_max (), we can another stack as a temporary storage. When we do pop_max (), we pop all the elements till the max, and store them in the other stack. Then remove the max. And the put the elements back to the stack.

Mote that, we in this case, approach b is easier to implement than approach a.

260. In c++, to iterate a string, do:

for (auto ch : str) {

}

260. robot-bounded-in-circle is a fasinating problem!!! Take a look at solution:

https://leetcode.com/problems/robot-bounded-in-circle/solution/

261. C++ template:

class Solution {
public:
    int maxArea(int h, int w) {
        
    }
};

262. To sort a vector in C++:

std::sort (horizontalCuts.begin(), horizontalCuts.end());

Not

std::sort (horizontalCuts);

263. In order to iterate a vector using index:

for (int i = 1; i < horizontalCuts.size(); i++) {

}

Not: 

for (int i = 1; i < horizontalCuts.count(); i++) {

}

264. Sometimes, I take a problem too seriesly. For instance, in maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts problem, I consider tree splitting approach and DFS. But, note that those are needed if you want to find the peaces. Here you don't. You just need to find the area of the largest peace. Thus, there is a much easier solution. Just read the Overview of:

https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/solution/

265. Sometimes, if the result is too large, you will be asked to return in "modulo 10^9 + 7"

You can do it as following:

unsigned int mod = 1000000007;

....

return  ((long long) max_weight * max_height) % mod;//here the result would be int

266. Sometimes, I get confused: "do I return or set the output in parameter in DFS?". In dfs(), like traditional recursion, return the output. But, in backtracking, set the output in a parameter. 

267. In design problem, if you need to the know the time, your API can accept a timestamp in sec/nanonec (instead of actual time).

268. C++ is really preferable for design problem over C. C++ requires much less code. The code also easier to understand because we can directly use map, unordered_map, vector, list, string, etc.

269. These are the steps for design problem.

a. You can draw a collaboration diagram for each use case, and then extract the class diagram. But, this is not really needed. You can directly jump with creating the classes you will need and add the APIs. Sometimes, you may need to write code for a function or think internally in your head to get the logic flow of a function and that's how you get the APIs of other classes. So, first find all the functional requirments for your design and write APIs for that. Then write APIs that will be needed to implement your functinal design APIs.

b. Then you need to decide which data structure do you need to implement the APIs.

c. Finally, check if there is any non-functional requirements.

270. Instead of writting logic in this format:

dp[i] = nums[i] + dp[i-2] > dp[i-1] ? nums[i] + dp[i-2] : dp[i-1];

write logic as:

dp[i] = max (nums[i] + dp[i-2], dp[i-1]);

It is more clear what's going on.


271. If you don't practice for a while, backtracking algorithm may look difficult. For instance, problem like :

https://leetcode.com/problems/different-ways-to-add-parentheses/
https://www.geeksforgeeks.org/print-all-combinations-of-balanced-parentheses/

looks difficult. You should write the output on paper. Then draw the backtracking tree. Then it becomes clear.

Moreover, like I previously said, different-ways-to-add-parentheses is not a backtracking problem. It is rather a divide and conquer / recursion / top-down approach problem (take a look at point 47 for details if you don't remember)

272. Using iterator in C++:

#include <iostream>
#include <vector>

using std::vector; using std::cout; using std::endl;

int main(){
   vector<int> intVector(10, 55);
   for(vector<int>::iterator it=intVector.begin(); 
       it != intVector.end(); ++it){
      cout << *it << endl;
   }
cout<< endl;
  
   for(auto it=intVector.begin(); 
       it != intVector.cend(); 
       ++it)
      cout << *it << " ";
   cout << endl;
  
}

Note that, iterator is not a static member of vector. It's an inner class..

273. What's wrong with following code:

    if (s[i] == stack[idx - 1]) {
      count[idx - 1]++;
      while (count[idx - 1] == k) {
          idx--;
      }
      
   }      

It should be:

    if (idx >= 1 && s[i] == stack[idx - 1]) {
      count[idx - 1]++;
      while (idx >= 1 && count[idx - 1] == k) {
          idx--;
      }
      
   }
   
I often forget to check that.
   
   
274. In trie, sometimes, I need to do:

if (!runner->children[s[j]-'a']) 

If I often do:

if (!runner->children[s[j]])

which causes very serious bug. It's hard to debug bacause you are accessing unknown memory. Please be aware!!!

Sometimes, you will get segfault. Sometimes, you will get weired errors like "load of value 138, which is not a valid value for type '_Bool'" 

275. In word-break and word-break-ii, you can consider words:

catsanddogs

dictionary: cat cats c at and sand dogs

276. In coin-change and coin-change-ii, you can consider an amout:

11/15/20 (arbitary..)

coins: 1 2 5

277. During interview, a tree can be drawn as:



                       3
                       
                  4            6
                  
               3       4    4       7
                        
                     7           6       9
                     
278. Some DP problem are also backtracking or recursion problem. But, problem with backtracking or recursion solution is that they will solve same subproblem over and over. So, if a problem is a backtracking problem, make sure you should solve it backtracking or recursion or DP. In this case, you should start with backtracking/recursive solution. Get the recursive equation. Then use the recursive equation to solve the problem in bottom up manner in DP (if possible).

Example of such problem is: coin-change, coin-change-ii, word-break, word-break-ii                      


Now, we can have many variants of coin-change and word-break problem.

For instance, coin-change problem, you are given a list of coins (e.g. 1, 2, 5) and an amount (e.g. 11). Now you can ask questions in many different ways:

a. Can the amount be made of the coins? (recusion is sufficient. Once we find out that yes, it's possible, we stop looking further)
b. What is the minimum number of coins need to make the amount? (coin-change problem)
c. How many different ways you can make the amount? (coin-change-ii problem) 
d. Return all the ways you can make the amount?

Mpral: Here, b-d should be solved using DP. Note that, besides optimizing something, DP can also be often used for the min/max number of way something can be done. DP can also be used to find all the different ways you can make up something. 

Again, word-break problem can have many variants. For instance, given a dictionary (e.g. and, sand, cat, cats, c, at, dog) and a string "catsanddog".

a. Can the string be made of the dictionary? (recursion is sufficient. Once we find out that yes, it's possible, we stop looking further)
b. What is the minimum number of ways to break up the string?
c. How many ways you can break up the string?
d. Return all possible ways to break up the string. (word-break-ii)

Think if you can solve all of them using DP.

279. Sometimes you need to read a file. In C++, do this:

void readRoster(list<string>& roster, string fileName){
   ifstream course(fileName);    
   string first, last;
   while(course >> first >> last)
      roster.push_back(move(first + ' ' + last));
   course.close();
}

In C, do as:

 FILE *fp;
  char v6str[256];
  char buff[4096];
  int ret;
  struct in6_addr v6addr;

  if ((fp = fopen(file, "r")) == NULL) {
    puts("File not exists");
    return -1;
  }
  
  while ( !feof(fp) ) {
    if ( !fgets(buff, sizeof(buff), fp) )
      continue;
    memset(v6str, 0, sizeof(v6str));
    ret = sscanf(buff, "%[^'\n']s", v6str);
    if ( ret < 0 ) {
      puts ("Invalid IP");
      return -1;
    }

    ret = inet_pton(AF_INET6, v6str, &v6addr);
    if ( ret < 0 ) {
      printf ("Invalid IPv6 prefix %s \n", v6str);
      return -1;
    }

    if (real_ip_cnt >= REAL_CNT) {
      puts ("The real traffic array is full. Ignoring rest of the traffic");
      return 0;
    }

280. Sometimes, you will be asked to tell about a problem that was really hard. Although you can talk about many such problem, the taughest problem I found was probably merge sort problems....!! But, once you get it, it's easy...

 
281. Generate 2^16 sequential IPv6 addresses within 2402:4f00:4000::/120


//  for (i = 0; i < SEQ_CNT; i++) {
//    seq_ips[i] = (((__uint128_t)0x24024F004000ULL) << 80) | ((__uint128_t)i);
//  }

282. Converts 128-bit IPv6 to a string of hex characters

static char* ipv6_to_str (__uint128_t ip) {
  //An IPv6 address needs 32 character + 1 for NULL
  char *str = new char[33];
  //We print __uint128_t by breaking into two uint64_t variables. We 
  //use %016"PRIx64" format specifier to print a uint64_t.
  sprintf(str, "%016"PRIx64"%016"PRIx64"", (uint64_t)(ip >> 64), (uint64_t)ip);
  return str;
}

282. Sometimes you will be asked about multi threading and synthronization. For instance, your routing table should not be updated while reading. Again, your reading should way before update is made. Recall that I don't use locking in my project. In Linux kernel, I used RCU.

https://en.wikipedia.org/wiki/Read-copy-update

283. Sometimes, I will be asked write down the struct that used in CP-Trie:

struct cptrie {
  uint8_t def_nh;
  struct cptrie_level level16, level24, level32, level40, level48, level56, level64, level72, level80, level88, level96, level104, level112, level120, level128;
  struct leaf leaf;
};

struct cptrie_level {
  struct bitmap_cptrie *B, *C;
  uint8_t level_num;
  uint32_t count;
  uint32_t size;
  struct cptrie_level *parent, *chield;
};

struct bitmap_cptrie {
    uint64_t bitmap;
    uint32_t cumu_popcnt;
};

struct leaf {
  uint8_t *N;
  uint8_t *P;
  uint64_t size;
  uint64_t count;
};

Note that, here we are encoding the trie with bitmaps. We then store it as arrays. PLease also take a look at my paper to refresh your mind.

284. For instance, your are asked to design an memory manager for an ASIC with where memory consist of 32X96b (32 consecutive bloack of 96b). How would you implement a memory manager?

I tend to use array where chunks are stored in a sorted order of their size. But, not that is will not be very efficient because although we find the chunk in O(logn), we need to rearrange the chunks after allocation. The best way here is to store bitmap. Here, lookup O(n), but we won't need to rearrange the chunks.

285. What is the lookup complexity and memory complexity of CP-Trie?  Lookup complexity is is O(1). Worst case memory complexity is O(n) because you may need to add a new chunk for each IP address where 'n' is the number of IP prefixes. What is the FIB update complexity? Update complexity is also O(n) because you need to find move check in one or multiple levels. As the number of levels are fixed, so the update complexity is O(n).

286. If I need to set n bits from m bitposition, I can do it in:

unint_64 res = input | ((1ULL << n) - 1) << m;

Although this is very simple, just writting it down so that I don't forget even though I used it many times!!!

I also often forget to declare 'res' unint_64, I mistakenly declare it 'int'.

Now, to clear n bits from  m bitposition, I can do it as:

unint_64 res = input & !(((1ULL << n) - 1) << m);

Sometimes, for some reason, I think, to invert bits, I need to use ~. But actually '!' is fine.
