1. Palindrome - an integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not.

2. Ask if input consists of just letter, or any ASCII character. For instance, in https://leetcode.com/problems/longest-substring-without-repeating-characters/, I thought it will only contain english letter, and I use arr[26] as a hash. This is not right. The input can contain both upper case and lower case. More importantly, it can contain any ascii charecter.

3. Note that, there are 256 ascii characters.

4. In  sliding window implementation, you can start end = [0 - end] and increase start on the way

5. Suppose you are given https://leetcode.com/problems/median-of-two-sorted-arrays/. You need to asked to solve in log (n + m). How would you do that? Actually, if you use two pointers for two arrays, it's actually log (n + m). This is because you don't need to iterate the whole array. Actually, no that's not right. If you use simple, two pointers, it's O(n+m). However, I saw my solution  was accepted and it was faster that 99...% solutions

6. https://leetcode.com/problems/reverse-integer/. Here, I thought, I will have to rotate the number in each step up to n times (n = num of digits). If you think clearly, if you ratate a number n times, you will get the same number. If you rotate n - 1 times, it will still give you wrong results. To get the right results, you need to swap between start and end.

7. We know that C++ string is immutatable. If we append or use '+' operator, it creates a new copy of the object. So, you may want to create a sring of a predefined length. You can do that as:

        string res(str_len, 0);//Here, we are assigning 0/NULL to each element of the string
        
8. https://leetcode.com/problems/base-7/. How many characters do you need for base 7? How do you convert a number from base 10 to base 7?

Recall that, for base-10 numbers, we can calculate the number of digits as = log10(num) + 1. It will work for any number, for instance, 99, 100,...

In the same way, base-2 number, the number of binary digits is = log2(num) + 1.

In the same way, for base-7 number, the number of digits = log7(num) + 1.

How to calculate log7(num)? There is no such library function.

log7(num) = log10(num) / log10(7).

Note that, this will not work if the number is negative. So, if the number is negative, you need to make it positive and then process it.


How do calculate base-7 number from base-10? 

Recall that, in Base-16, we divide by 16 in each step, and get the quotient (result of the division) and remainder. We divide the quotient again by 16. We repeat these utill quotient is 0. Like:

16 |45
   |---------------------
16 |2 - 13 (D)
   -----------------------
   |0  - 2 (2)
   
So, Hex of 45 is 2D   

In the same way, for base-7, we need to divide by 7.

Will this work if input is 0? No. You need to handle 0 separately. If the number is negative, you also need to make the number positive first.

9. https://leetcode.com/problems/reverse-linked-list/ Here, I need to set head = nullptr.

10. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ Here, we can use mid = (start + end) >> 1

11. https://leetcode.com/problems/reverse-bits/. Note that reversing is not same as circulating. I often make this mistake. Remember string reverse procedure

12. https://leetcode.com/problems/reverse-bits/ Here, if (n & mask2 == 0) will not work. It should be if ((n & mask2) == 0)

13. https://leetcode.com/problems/linked-list-cycle-ii/. Detecting cycle is easy. How would you find the start of the cycle?

Don't go into theory. That's just for correctness proof. Idea is only you find the intersection of fast and slow pointer, do the following. Have ptr1 point the head and have ptr2 point the intersection. Then go only one step at a time for both case. When they meet, that's the start of the cycle.

14. https://leetcode.com/problems/invert-binary-tree/

Here, I set left-subtree = invert(right-subtree). Problem here is it will update the tree in place. Don't do that. Create a temp, left, right. Then update the tree based on left and right as:

        TreeNode *left = invertTree (root->right);
        TreeNode *right = invertTree (root->left);
        root->left = left;
        root->right = right;

15. https://leetcode.com/problems/sqrtx/

A binary search needs to be in the form:

while (end >= start) {//Not end > start
  mid = (start + end) >> 1;
  if (target == arr[mid])
    return mid;
  else if (target > arr[mid])
    start = mid + 1;//NOT start = mid (leads to infinite loop)
  else
    end = mid - 1;  //NOT end = mid (leads to infinite loop)
}

Also, in the problem, don't do:

 if ((x + 1) * (x + 1) > target) 
 
 What's wrong here? It may overflow for some input. Even if(x + x > target) or if (x * x > target) may overflow.
 
 If you need to calculate sum or multiplication of int/float, check if you need "long long" (for int) or "double" (for float) to store it. Otherwise overflow happens. If you need long long or double, also change the expression to make sure that longlong or double is stored. For instance,

int a, b;
long long sum;

sum = (long long)a + b;

Just changing to long long inline doesn't work.

In some cases, you may not need "long long". Just "long" is enough.

16. https://leetcode.com/problems/kth-largest-element-in-a-stream/

What's wrong with the code?

	vector<int> nums;
        for (int i = 0; i < nums.size() - k; i++) {

        }
        
Here, nums.size() is unsigned. If nums.size() - k is negative, that expression will accidentally create a large number. So, the loop will mistakenly run many iteration whearas it shouldn't iterate at all.
        
Following doesn't fix it.


        for (int i = 0; i < (int)nums.size() - k; i++) {

        }
        
This however fixes it:
        
        int num_delete = nums.size() - k;
        for (int i = 0; i < num_delete; i++) {

        }
        
17. https://leetcode.com/problems/power-of-three/ 

Look at the following solution:

    bool isPowerOfThree(int n) {
        if (n <= 0)
            return false;
        
       float x = (float)log10(n) / log10(3);
       return ceil(x) == x;//See how we are checking if x is an integer.
    }
    
    What's wrong with the code? Here, it should be:
    
    double x = log10(n) / log10(3);
    
    Casting it to float may lose precision, which causes wrong result. Also, x should be double.
    
18. https://www.geeksforgeeks.org/position-of-rightmost-set-bit/

The process is:
     
    unsigned int getFirstSetBitPos(int n)
    {
        return log2(n & -n) + 1;
    }
    
    If you take negative of the number (two's complement) and & it with the original #, all the bits except the right most one is set. Then, use log to calculate the bit position.
    
    For instance, n = 100011100
    
    One's complement of n = 011100011
    Two's complement of n = 011100100. This is -n
    
    Now, n & -n = 100.
    
19. https://stackoverflow.com/questions/325933/determine-whether-two-date-ranges-overlap/325964#325964
    https://leetcode.com/problems/rectangle-overlap/
    
Here, we need to write the condition such that they don't overlap, instead of checking overlapping. For rectangale, first remember how you do it for line. That will help you to come up with logics for rectangles.
    
20. https://leetcode.com/problems/number-of-days-between-two-dates/. How to solve this? Trying to implement distance between them is hard/messy to implement. But, if you try to calculate # of days since 1970, that's clean to implemt. So, implement that, and then take the distance as:

class Solution {
    bool is_leapyear(int year) {
        if (year % 100 == 0)
            return year % 400 == 0;
        return (year % 4 == 0);
    }
    
    int since_epoc (string date) {
        int months[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        int year = stoi(date.substr(0, 4));
        int mon = stoi(date.substr(5, 2));
        int day = stoi(date.substr(8));
        
        int i = 1970;
        while (year > i) {
            day += is_leapyear(i) ? 366 : 365;
            i++;
        }
        for (int i = 1; i <= mon - 1; i++) {
            day += months[i];
            if (i == 2 && is_leapyear(year))
                day++;
        }
        return day;
    }
public:
    int daysBetweenDates(string date1, string date2) {
        //cout << since_epoc (date2);
        return abs(since_epoc (date2) -  since_epoc (date1));
    }
};

Note how we represented # of days in a month. That's more clean than having switch/if to clauclate it.

21. https://leetcode.com/problems/valid-square/

Very interesting problem. Try to find how you would solve it. 

Trick is to sort the numbers. That way, you know what is the bottom left and top right.

22. https://leetcode.com/problems/snakes-and-ladders/

How would you convert <x, y> to the number? Think in terms of math. Here, we are doing that:

        for (int i = board.size() - 1; i >= 0; i--) {
            for (int j = 0; j < board.size(); j++) {
                if (right)
                    jump[(board.size() - 1 - i) * board.size() + j + 1] = board[i][j];
                else
                    jump[(board.size() - 1 - i) * board.size() + (board.size() - 1- j) + 1] = board[i][j];
            }
            right = !right;
        }   
    
23. https://leetcode.com/problems/product-of-array-except-self/

How can you implement this without using division?

You can have two arrays L and R. L will contain multiplication of all the number to the left of index i. R will contain multiplication of all the number to the right of index i.
Then for each index, you can do L[i] * R[i]     


24. https://leetcode.com/problems/3sum/

Here, challenge is how to make sure you don't put same result twice?

You may try to use hash. But, it will not work. Beacuse, the numbers inside result will not be in the same order. Besides, you iterate samrtly so that you can avoid duplicate.

First of all, sort the array. In outer array, check if the number you are dealing is same as the previous number. If yes, you can skip that.

In the inner array where you are doing two sum, if you find a match for a number, increase the index until the next number is same as the previous number. 

The code will look as following:

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        int target_sum;
        
        sort (nums.begin(), nums.end());////<<<<<<<<<<<<<<<<<<<<<
        for (int i = 0; i < nums.size() - 2; i++) {
            if (i > 0 && nums[i] == nums[i-1]) {////<<<<<<<<<<<<<<<<<<<<<
                continue;
            }
            target_sum = 0 - nums[i];
            unordered_set<int> set;
            for (int j = i + 1; j < nums.size();) {
                if (set.count(target_sum - nums[j])) {
                    vector<int> inner (3);
                    inner[0] = nums[i];
                    inner[1] = nums[j];
                    inner[2] = target_sum - nums[j];
                    res.push_back(inner);
                    j++;
                    while (j < nums.size() && nums[j] == nums[j-1])////<<<<<<<<<<<<<<<<<<<<<
                        j++;
                    continue;
                }
                set.insert(nums[j]);
                j++;
            }
        }
        return res;
    }
};

25. https://leetcode.com/problems/3sum-closest/

How do you calculate the distance between target and sum? Note that, both can be positive and negative.

When doing this, I made it overly complicated, and created a separte function for this. But, it should be abs(target - sum). Think about it. It will work for both positive and negative.

Now how would you implement this?

What I thought was, I would use two pointer approach. I will keep track of the last diff. In two pointer iteration, I would minimize the diff. If we see that diff is increasing compared to previous diff, we should break. This is not right. If diff increases, you should not break because you can still find a smaller diff. Then what's the point of using two pointers? The main benefit is, if we find a diff 0, we can immediately stop.

I also was thinking about 3 nested loop, because I though the inner loop will stop pretty soon. This is not the right approach either. First of all, this is O(n^3). Two pointer approach make the same problem O(n^2)

26. https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/

Do you implemement using DFS or BFS? I think, both solution works. But, text books are other solutions uses DFS instead of BFS. I didn't find a good explanation why. At first, I though DFS would be better because we don't really iterate all the edges. As DFS goes to depth first, it will find the solution sooner. But, this is not the case. Both DFS and BFS is O(E + V). DFS will eventually check all the edges of the nodes along the way (if the node isn't already visited). So, I think, there is a chance that DFS would be better, but it's not certain.

Also, how would you create adjacency list here?

I am inclind to think that, here I can create it as:

        for (auto &e : edges) {
            adj_list[e[0]].push_back(e[1]);
        } 
As I am primarily interested to mark all the nodes, so I don't really consider opposite direction of the edge. This however will not work in all the cases. We don't know which we will be visiting the nodes. So, correct answer should be: 
        
        for (auto &e : edges) {
            adj_list[e[0]].push_back(e[1]);
            adj_list[e[1]].push_back(e[0]);
        }
        
        
27. https://leetcode.com/problems/delete-node-in-a-linked-list/

Do you remember the trick? If you remember, then you are find. Otherwise just take a look at the solution. Implementation should be easy.     

28. Try to remember if you can implement in-order, pre-order, post-order travarsal without recursion.

29. Note that many tree problem such as LCA and find distance between two nodes can be implemented by using recursion on left and right. Think hard how you can formulate that.

30. https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

How would you implement this?

I generally think that, I will find a min to the left and max to the right. Then I will increase the min until I find a lower min. I usually do this because I treat loop as stateless loop. But, we can add state in a loop and do wonderful things. Try to find out if we can have multiple states so that we can find it in one iteration. If you can't, look at the leetcode solution.

31. How to implement heap? priority queue. How to implement max heap? This is simply:

priority_queue<int> q;
p.top()//Note this is not p.front()

For min heap, it should be:

priority_queue<int, vector<int>, greater<int>> pq;//yes, greater<int>, not 'greater' or 'less'. You also need to add vector<int>  

Also, note that priority queue can have size as: pq.size() 

Note that, we generally don't create a heap of size n (I sometimes think of this). We create an empty heap and then add/delete elements to it.

Also, pushing in priority queue is:

pq.push(elem);///<<<Not pq.insert (). Sometimes I mistakenly think so

32. https://leetcode.com/problems/validate-binary-search-tree/

How would you implement this? It may look simple on the surface, but note that all the nodes in left subtree has to be smaller. Try to find the solution. Look at my solution if you can't find.

Here is the soluton.

class Solution {
    bool isValidBST_inner(TreeNode* root, long min, long max) {//<<<<<<<<<<<<
        if (!root)
            return true;
        if (root->left && root->left->val >= root->val)
            return false;
        if (root->right && root->right->val <= root->val)
            return false;
        
        if (root->val >= max || root->val <= min)
            return false;
        
        return isValidBST_inner(root->left, min, root->val) && 
               isValidBST_inner(root->right, root->val, max);        
    }
public:
    bool isValidBST(TreeNode* root) {
        return isValidBST_inner(root, (long)INT_MIN * 2, (long)INT_MAX * 2);//<<<<<<<<<<<<
    }
};

Note that the pointers. You can actually avoid it by passing node pointer instead of the value (as leetcode solution suggests)

Note that, this problem can be solved using in-order travarsal. If you do in-order travarsal, the nodes will be visited in sorted order. Implementing in-order in recursive manner is easy, but implementing it in iterative manner isn't easy. Here. we are implementing it using recursive in-order.

class Solution {
    
    bool isValidBST_inner(TreeNode* root, TreeNode* &prev) {
        bool ret;
        
        if (!root)h?
            return true;
        ret = isValidBST_inner(root->left, prev);
        if (!ret)
            return false;
        if (prev && root->val <= prev->val)
            return false;
        prev = root;
        ret = isValidBST_inner(root->right, prev);
        if (!ret)
            return false;
        return true;
    }

public:
    bool isValidBST(TreeNode* root) {
        TreeNode* prev = nullptr;
        return isValidBST_inner(root, prev);///<<<<<<
    }
};

Note that, if you try to pass a default value at the pointer, the program will be error prone. Passing pointer is less error prone.


33. https://leetcode.com/problems/search-in-rotated-sorted-array/

How would you implement this? What I try to do is do binary search. During binary search, I try to increase/decrase the mid based on which part I'm in. I found it extreamly difficult to solve although leetcode solution 2 use the same approach. Easier approach is to use binary search to find the smallest element. Then do two separate binary search on two parts.

How would you find the smallest element using binary search? To solve this problem (like stock buy sell problem), draw the points as following:


         A
       A
     A
   A
A  
                 A
               A
             A
------------------------------
Now you can see what logic to use to find the smalles index. If you don't, look at the solution or leet code approach 1.

34. https://leetcode.com/problems/set-matrix-zeroes/

How would you implement? Note that, evenn though you asked to use O(1) space, you can use additional variable

35. https://leetcode.com/problems/kth-largest-element-in-an-array/

Note that, this is asked to solve in O(n). If you use heap, this is not exactly O(n). It's O(nlong). But, that's OK.

36. https://leetcode.com/problems/insert-interval/

Draw interval on paper and thing how would you implement binary search here. It seems that you can use binary search here, but you cannot. Look at the eaxmple:

------      ---------  ------------           -----------    ----------

        ---------- (to insert). You can use binary search to find the insertion point for this.
 -------------------------------------------------- (Now how about this? What would be the conditio that you use to do binary search both situation). I couldn't formulate an easy condition. Leetcode solution also use sequencial serach.
 
 37.    vector<vector<char>> mat(numRows);
        for (int i = 0; i < numRows; i++) {
            mat[i].resize(num_col);
        }
        
Note that, all the elements of the vector will be 0 by deafault.

38. https://leetcode.com/problems/zigzag-conversion/

Here, I use 2D array to implement this. Can you make it better?

Note that, you can simply have a vector<string> instead of 2D array.        
 
 
37. https://leetcode.com/problems/min-cost-to-connect-all-points/

How would you implememt this?

How would you implement MST?

https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/
https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/

Suppose, you want to implemenmt Kruskal's algorithm. How would you implement it?

How would you check cycle in it? DFS? I sometimes think that I can keep track of visit[] for each point. Can I use that to detect cycle?

You can't. Think of the following:

A     C
|     |
|     |
B     D

All the points are visited, but you can still add edge between A and C. 

So, detecting cycle in graph using DFS is expensive. You can use the above intuition to implement disjoint set data structure.

How would you implement disjoint set?

One option is to have a vector<unordered_set<int>>. This is expesive. How would you merge disjoint sets? We need a data structure that supports that.

class DisjointSet {
    vector<int> parent;
public:    
    DisjointSet (int n) {
        parent = vector<int>(n);//<<<<<<< See how we are creating a vector dynamically for member variable
        
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }
    
    int find (int n) {//<<<< find
        while (n != parent[n]) {
            n = parent[n];
        }
        return n;
    }
    
    bool merge (int a, int b) {//<<<< Merge
        int p1 = find (a);
        int p2 = find (b);
        
        if (p1 == p2)
            return false;
        parent[p1] = p2;
        return true;
    }
};

The total solution is:

class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        vector<vector<int>> edge_list;
        
        for (int i = 0; i < points.size(); i++) {
            for (int j = i + 1; j < points.size(); j++) {
                vector<int> edge(3);
                edge[0] = i;
                edge[1] = j;
                edge[2] = abs (points[i][0] - points[j][0]) + 
                    abs (points[i][1] - points[j][1]);
                edge_list.push_back(edge);
            }
        }
        
        sort (edge_list.begin(), edge_list.end(), [](vector<int> &v1, vector<int> &v2) {
            return v1[2] <= v2[2];
        });
        
        DisjointSet ds(points.size());
        int cost = 0;
        int count = 0;
        for (auto &e : edge_list) {
            if (ds.merge(e[0], e[1])) {
                count++;
                cost += e[2]; 
                if (count == points.size() - 1)//<<<< See we can stop early when we have n-1 edges
                    return cost;
            }
        }
        return 0;
    }
};
       
38. https://leetcode.com/problems/partition-list/

How would you implement this? Note that, sometimes it's OK to create a dummy pointer (ListNode dummyNode), just to avoid complicated check;

39. https://leetcode.com/problems/all-paths-from-source-to-target/

How would you implement it? Note that, you need to implement backtracking in DFS. It is easier to implement backtacking DFS in recursive manner instead of iteratve manner.

40. https://leetcode.com/problems/powx-n/

How would you implememnt this?

I generally do: pow (x, n/2) * pow (x, n - n/2). But, note that, you are calling almost similar function twice. This will result in TLE. You can rather do:

            res = myPow(x, n/2);
            res = res * res;
            if (n & 1)
                res *= x;
                
Also, note that, if n is negative, you need to do n = -n. This will however cause overflow for the largest negative integer. To solve this problem, do following:

        long N = n;
        bool neg = n < 0;

        if (neg)
            N = -N;                

41. https://leetcode.com/problems/reverse-integer/

How to solve this? I generally solve as:

https://leetcode.com/problems/reverse-integer/

class Solution {
public:
    int reverse(int x) {
        unsigned int X = x < 0 ? -x : x;//<<<<<<Can it cause overflow? Ypu would think No, because it's unsigned. But it will overflow. Use abs() to achive this

        unsigned int num = 0;
        while (X) {
            num = num * 10 + X % 10;//<<<<<<Can it cause overflow? Yes. I usually solve this uinng "long" or "long long", but we cannot use 64 bit int here. 
            X = X/10;
        }

        return x < 0 ? -num : num;
    }
};

Note that, not being able to use 64 bit int is the main challenge here. We need to implement in a way that it can detect overflow. Now, we need to detect overflow before it actually happens. Because if overflow happens, you cannot detect it. So, we can use following approach:

class Solution {
public:
    int reverse(int x) {
        bool neg = x < 0;
        unsigned int X = abs(x);///<<< Don't do -x. It will cause overflow

        unsigned int num = 0;
        while (X) {
            if (!neg && (num > INT_MAX/10 || (num == INT_MAX/10 && X % 10 > 7))) {///<<<<<See how we are avoiding overflow for positive #
                return 0;
            }
            if (neg && (num > INT_MAX/10 || (num == INT_MAX/10 && X % 10 > 8))) {///<<<<<See how we are avoiding overflow for negative #
                return 0;
            }
            num = num * 10 + X % 10;
            X = X/10;
        }

        return neg ? -num : num;
    }
};  

42. https://leetcode.com/problems/lru-cache/

How would you implememnt this? 

I tend to use hash and heap. I also though about using hash and queue. But, if you think carefully, they will not work. But, note that, you can implment using hash + linked list where hash points to the linked list nodes. Everytime you access a node, that node will be pushed to the head. When we delete a node, we will be delete from tail. Which linked list should you use? should you use std::list?

I found that moving around items can be difficult in std::list. So, avoid it. Implement your own list unless what you are doing something trivial like push_back(), pop_back(), push_front(), pop_front(). Note that, std::list has those functions. Although list has splice() that allows you to insert one list into another, it's hard to use if you want to reorder nodes in a list using it. Probably, this is why so mamy leetcode C++ questions still use manual linked list.

Now, would you use single linked list or double linked list? Note that, here double linked list will result in O(1) reoorder (although Single linked list also can have tail)

When implementing linked list of your own, don't forget to do these:

class Node {
public:
    int key;
    int val;
    Node *next;
    Node *prev;
    Node(int k, int v) {
        key = k;
        val = v;
        next = nullptr;//<<<<<<<<I usually forget this
        prev = nullptr;//<<<<<<<<I usually forget this
    }
};

Also, remember that hash has size() function that can give us the size. Hash also has following way to delete a key:

hash.erase(key_to_del);//<<<<You don't need to pass an iterator

43. https://leetcode.com/problems/lfu-cache/

How would you implememt this? 

I think of implememting as hash + priority_queue. Here, priority_queue will contain the nodes (with frequency) and hash points to the node. This however will not work. Because, in C++ priority_queue, you only get top and you can only do push() which will add the item to the bottom of the tree. But, in this case, we may need to update the frequency of an intermediate node. If you do that, priority_queue acts abnormally. To solve this, we can implement our own heap.

Now, even though we don't use heap, let's take a how the heap code would look like:

struct Elem {//<<<<<<<Note that stuct/class name should begin with capital letter.
    int key;
    int val;
    int freq;
    Elem(int k, int v, int f) {//<<<<<<<<<<<<You can add constructor in struct like a class
        key = k;
        val = v;
        freq = f;
    }
};

unordered_map<int, Elem *> hash;//<<<<<Notde that, you don't need struct keyword for struct
Elem *new_elem = new Elem(key, value, 1);//You can also create a struct onbject like a class

//<<<<<Note how functor is written
struct Comp{
    bool operator()(Elem *e1, Elem *e2){//<<< Note that there are two "()". You also need to return true
        return e1->freq < e2->freq;
    }
};

priority_queue<Elem *, vector<Elem *>, Comp> pq;//<<<<<For custom object, we need to give less/greater than function. Here, we need to provide a functor
               
Now, even though you could implement your own heap, that will require you update multiple elements in every iteration. Can you do better?

Yes, you can have a hash<frequency, nodelist>. Here, you will keep all the nodes that have the same frequency in the same bucket. When you update the frequency, you simply need to move the node from current bucket to new bucket. You may think that, here we need linear search to find the node. But, actually you don't. Note that, each node is allocated dynamically. Here, we simply keep the pointer to the node, not the actual node. So, this frequncy hash and key hash will point to the same node. You can move nodes easily around.

You so you need to two hash, right? One keep track of <key, Node*>, another <freq, node>. But, note that, in case of <freq, node>, you sometimes need to find the smallest frequncy? How can you do that. Use map!!!! Remember that map is an ordered_map (internally a red black tree). So, you can easily find the smallest freq as:

map.begin()..

Now, in the requirment it also says that, if there are multiple LFU element, evict the LRU element. So, you need to keep track of the LRU as well. So, solve this problem, we always insert at the end of the list and evict from the head of the list. To implemement that efficiently, we need both head and tail. So, this is the actual implementation:

/*
https://leetcode.com/problems/lfu-cache/
*/
struct Node {
    int key;
    int val;
    int freq;
    Node *next;
    Node *prev;
    Node(int k, int v, int f) {
        key = k;
        val = v;
        freq = f;
        next = NULL;
        prev = NULL;
    }
};

class LFUCache {
    unordered_map<int, Node *> hash;//<<<<.....
    map<int, pair<Node*, Node*>> freq_list;//<<<<See how we are keeping both head and tail
    int size;
    
    void insert_last(Node* &head, Node* &tail, Node *to_insert) {
        if (!head) {
            head = to_insert;
            tail = to_insert;
        } else {///<<<<<In linked list manipulation, everytime you have a condition, make sure to think if you need to do if the condition doesn't hold (i sometimes miss that)
            tail->next = to_insert;
            to_insert->prev = tail;
            tail = tail->next;
        } 
    }
    
    void delete_cur(Node* &head, Node* &tail, Node *to_del) {//<<<<<Note how we pass pointer by reference. It's not like: "Node &*head"
        if (head == to_del) {
            head = head->next;
            if (head)
                head->prev = NULL;
            else
                tail = NULL;
        } else if (tail == to_del) {
            tail->prev->next = NULL;
            tail = tail->prev;
        } else {
            if (to_del->next) {
                to_del->next->prev = to_del->prev;   
            }
            to_del->prev->next = to_del->next;
        }
        to_del->next = NULL;
        to_del->prev = NULL;
    }
    
    void print_freq() {
        cout << "printing freq list:\n";
        for (auto it = freq_list.begin(); it != freq_list.end(); it++) {
            Node *r = it->second.first;
            while (r) {
                cout << "key = " << r->key << " value = " << r->val << " freq = " << r->freq << endl;
                r = r->next;
            }
        }
    }
    void delete_frm_freq (int key) {
        //auto p = freq_list[hash[key]->freq];
        //delete_cur(p.first, p.second, hash[key]);//<<<Will this work? No, because it will update the local head/tail, not the actual head tail.
        delete_cur(freq_list[hash[key]->freq].first, freq_list[hash[key]->freq].second, hash[key]);//<<<<<You need to implement as this
        if (freq_list[hash[key]->freq].first == NULL) {
            freq_list.erase(hash[key]->freq);         
        }
        hash.erase(key);
    }
    
    void move_upper (int key) {///<<<If you see that you need to use same logic again and again, don't be lazy. Create a separate func. It will make it much easier going forward
        delete_cur(freq_list[hash[key]->freq].first, freq_list[hash[key]->freq].second, hash[key]);
        if (freq_list[hash[key]->freq].first == NULL) {
            freq_list.erase(hash[key]->freq);   
        }
        hash[key]->freq++;
        insert_last(freq_list[hash[key]->freq].first, freq_list[hash[key]->freq].second, hash[key]);        
    }
public:
    LFUCache(int capacity) {
        size = capacity;
    }
    
    int get(int key) {
        if (size == 0)
            return -1;
        auto it = hash.find(key);
        if (it == hash.end())
            return -1;
        move_upper(key);
        return hash[key]->val;
    }
    
    void put(int key, int value) {
        if (size == 0)
            return;
        auto it = hash.find(key);
        if (it != hash.end()) {
            move_upper(key);
            hash[key]->val = value;
        } else {
            if (hash.size() == size) {
                int key_to_del = freq_list.begin()->second.first->key;
                delete_frm_freq(key_to_del);
            }
            Node *n = new Node(key, value, 1);
            insert_last(freq_list[1].first, freq_list[1].second, n);
            hash[key] = n;
        }
    }
};


44. How would you implement a unorded_map<pair<int, int>, bool>? Note that, this will not work because it does not know how to use pair<int, int> as key (it doesn't know how to hash it). So, you need to provide your own hash function.  Note that, in  43, we defined priority_queue with custom object. There we implemented () oprator in Cmp. There we passed two Elements of priority queue and we compared them. But, here, we just need to pass one element of the hash and calculate the hash as following.

struct HashFunc {//<<<This can be a struct and define it outside of the class
    int operator()(const pair<int, int> &p) const {//<<<<You only need to pass the key as reference. 
                                                   //<<<<The return value is int. parameter and function, both has to be cosnt. Otherwise, you will get compilatio  error.
        return  p.first * p.second % 100;//<<<Define a hash function any way you like 
    }    
};

class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        string res;
        unordered_map<pair<int, int>, string, HashFunc> hash;//<<<Here you need to pass the hashfunc as third argument
}        
        
Howwould you use hashset instead? I often forget this.

It would be like:

unordered_set<int> hs;//<<<Not "hash_set" or "hashset"
hs.insert(5);//<<<<<<Not hs.push_back(5);

if (hs.count(5))//<<< this  is how we lookup.

We can also use find() in the same way as hash.
              
45. From Dr. Nesterenko's slide, you can append strings in two ways:

string s = "Hello";

s = s + " world";
s.append(" world");

Both are fine. Don't worry about creating stringbuffer.

Also, note that std::string doesn't have strcpy(). For instance, this will not compile:

tmp.strcpy(s, i, s_idx);

So, if you need to copy part of the string to another string, use "+".

Also note that, Following is not allowed!!!! (I often try this). Dr. Nesterenko's slide mentioned this
s = "Hello" + " world";//<<< You cannot apply "+" operartor on "Hello"

You also cannot do:

string s = 'a';


Also, how would you create a string of size 9?

string s(9)//<<<<Not right. This will work for vector, not for string.

Do this:

string s;
s.resize(9);

In most of time, create an empty string with "string s;". And then append to it.

How to earse part of the string?

tmp.erase(tmp_idx);//<<< Erase everything from tmp_idx to the end.
s.erase(0, num_spaces);//<<<It will erase num_spaces spaces from index 0


Sometimes, to erase one character, I write code like://<<<<<<<<<

s.erase(i);//<<<<<<This will erase everything from index i to end!!!!!!!, so don't do that, unless that's what you want


How to create substring? This is often used;

string sub = s.substr(offset, len);
string sub = s.substr(offset);//<<<In this case, it will return everything from the offset


How to convert string to number?

int a = atoi(s.c_str());


How would you search a char or string within a string? From Dr. Nesterenko's slide, you can do:

pos = s.find('.');//<<<This will find from the beginning
pos = s.find('.', start);//<<<This will start from index 'start'

if (pos == string::npos)//<<<not that, this is string::npos, not s::npos. What is string::npos. This is actaully a static const int whose value is -1.
  cout << "The string was not found";
  
I sometimes mistakely think that we can use substr() to find substr. Note the difference between substr() and find().!!!!////<<<<<<<<<<<<  
  
If you want to search multuple times in a string for example in https://leetcode.com/problems/compare-version-numbers/.

You can always start from "pos + 1". But, when you reach string::npos, adding 1 will make it start searching from the beginning. So, idea is if you reach the end, you should start looking from index = length_of_the_string. For instance, this is the solution of the above problem:

    int compareVersion(string version1, string version2) {
        int pos1 = 0, pos2 = 0, start1 = 0, start2 = 0;
        int rev1, rev2;
        
        do {
            pos1 = version1.find('.', start1);
            pos2 = version2.find('.', start2);
            
            if (pos1 == string::npos) {
                rev1 = atoi(version1.substr(start1).c_str());
            } else {
                rev1 = atoi(version1.substr(start1, pos1 - start1 + 1).c_str());
            }
            
            if (pos2 == string::npos) {
                rev2 = atoi(version2.substr(start2).c_str());
            } else {
                rev2 = atoi(version2.substr(start2, pos2 - start2 + 1).c_str());
            }
            
            if (rev1 < rev2)
                return  -1;
            else if (rev1 > rev2)
                return 1;
            if (pos1 != string::npos)
                start1 = pos1 + 1;
            else
                start1 = version1.length();//<<<<If you reach end, start past the last character. Even starting from the last character will have wrong result
            if (pos2 != string::npos)
                start2 = pos2 + 1;
            else
                start2 = version2.length();
        } while (pos1 != string::npos || pos2 != string::npos);
        
        return 0;
    }
};  


Can you do this?

    stack<string> s1;
    s1.push('a');
    
 No. you cannot do that.
 
 You also cannot do:
    s1.push("" + 'a');
    
You need to do:
   string tmp;
   tmp += 'a';
   s1.push(tmp); 
   
Following will not also work:
   string tmp = "" + 'a';
   s1.push(tmp); 

How to insert one string to the beginning of another string?
   
     s.insert(0, "hello");//<<<Note here we need to set the index, not the iterator
     
Following will not work, but sometimes I mistakenly try it:     
     s.insert(s.begin(), "hello");
     
Also, you cannot insert a character into a string. You need to convert the character to string before inserting  
     chat c = 'a';
     s.insert (0, c);//<<<<This doesn't work!!!!!! 
     
Anytime, you need to insert a character at the beginning, do:

s.insert(0, "A");////<<<<<<<<<<<<<< I often forget this. I also do: s.insert("A", 0)          

46. How to initalize a vector? Can you initialize a vector of vector? Can you initialize in class declaration or you need to do it inside function? 

You can all of these. You can do it as:

class Solution {
        vector<vector<char>> map = {
            {' '},
            {},
            {'a', 'b', 'c'},
            {'d', 'e', 'f'},
            {'g', 'h', 'i'},
            {'j', 'k', 'l'},
            {'m', 'n', 'o'},
            {'p', 'q', 'r', 's'},
            {'t', 'u', 'v'},
            {'w', 'x', 'y', 'z'},
        };
    void letterCombinations_inner(string digits, int idx, 
                                  string &cur, vector<string> &res) {
    }
public:
    vector<string> letterCombinations(string digits) {

    }
};

47. How to check if number is a digit or alpha or alphanumeric? How to check if a character is upper or lower?

isahpha()
isdigit()
isalnum()//<<<This is not isalphanum().
islower()
isupper()
ispunct()
isspace()
tolower()
toupper()

How would you check if a string is a number? Note that there is no isnum(), or isnumber() or isnumeric() even though there is isalnum().

You can do this to check if a string is a number;

if (isdigit(s[0])) ///<<<< But this will not work for negative number.

So, right solution is do:

if (isdigit(s[s.length() - 1])) 

The functions are taken from Dr. Nesterenko's example.

48.     bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size();//<<<Always do this, instead of using matrix.size() or arr.size() all the time
        
        
49. Sometimes, I debate weather to use DP or backtarcking? Note that thehy are very different problem. DP is optimization problem wheereas backtracking find all the combination.

50. https://leetcode.com/problems/search-a-2d-matrix-ii

How would you solve this?

I tend to use BFS. But, can you do better? Remember, if you need to do some sort of search, and the numbers are sorted, you can do better => Bibary search.

How would implement binary search here? This is not very clean. Pretty messy. Can you do better?

How about do DFS from top-right or bottom left? What is the benefit? Search space is shrinked. If we start from top-left and bottom-right, search space is huge, because both in creasing or descreasing. If you start from top-right, you only need to visit either left or down. Note that, you don't really need DFS here.

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();//<<<<<<<ALWAYS DO THIS. Makes code much cleaner and easier
        int row = 0, col = n -1;
        while (row >= 0 && col >= 0 && row < m && col < n) {
            if (matrix[row][col] == target)
                return true;
            else if (target > matrix[row][col])
                row++;
            else
                col--;
        }
        return false;
    }
};

51. How would you define 2D array?

int arr[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};//<<<<<<


Not:

int arr[][] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
int arr[4][] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
int arr[][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};

52. https://leetcode.com/problems/evaluate-reverse-polish-notation/ 

Here, you need to implement something like:

    int eval (char ch, int a, int b) {
        switch(ch) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return a / b;
        }
        return 0;
    }

What's wrong with this? Even though the final result of the problem is an integer, there is no guarntee that intermediate nuumbers are. So, it can overflow. Anytime you do "+" or "*", think if you need to store in a long instead of int as:

    long eval (char ch, long a, long b) {
        switch(ch) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return a / b;
        }
        return 0;
    }

52. https://leetcode.com/problems/minesweeper/

I had hard time understanding the requirement. Most important part is:

If a cell is unrevealed, and at least one of it's neighbor is revealed, just count how many mines are there around the cell (revealed or unreaveal mines). Then replace the cell with that number.

If a cell is unrevealed and all it's neighbors are unrevealed, the recursively unreveal the neighbors.


53. How would define a Trie node?

struct Node {
//  char ch;//<<<<Note that, in trie, edge represents the value. So, you don't really need this. I often mistakenly add this. Don't do it
  unordered_map<char, Node *> child;//<<< You can have a hash instead of array 
  bool isLeaf;
  Node(char c) {
//      ch = c;
      isLeaf = false;
  }  
};

54. https://leetcode.com/problems/top-k-frequent-elements/ 

How would you implement this?

Note that, heap is a magical data structure. You can throw number number to it and then extract numbers in greater/smaller order without sorting.

Now, remember https://leetcode.com/problems/lfu-cache/

Can you use heap there as well?

No, there we needed to modify the count on the fly. Heap is not good for that (unless you create your own heap). In order to use heap, we have to have frequency of the element readily avaialable like https://leetcode.com/problems/top-k-frequent-elements/

Now, look at the following implementation. What's wrong with this? What is the runtime of the program?

struct Cmp {
    bool operator()(pair<int, int> &p1, pair<int, int> &p2) {
        return p1.second < p2.second;
    }    
};

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> hash;
        priority_queue<pair<int, int>, vector<pair<int, int>>, Cmp> pq;
        vector<int> res(k);
        
        for (auto e : nums)
            hash[e]++;
        
        for (auto &e : hash) {
            pq.push(e);
        }
        
        for (int i = 0; i < k; i++) {
            res[i] = pq.top().first;
            pq.pop();
        }
        
        return res;
    }
};

Note that, we are creating a heap of size n. If we do that, cost of constructing the heap would be nlogn. So, no benefit. In order for the heap to be effective, the heap size should be k. Look at the code:

struct Cmp {
    bool operator()(pair<int, int> &p1, pair<int, int> &p2) {
        return p1.second > p2.second;
    }    
};

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> hash;
        priority_queue<pair<int, int>, vector<pair<int, int>>, Cmp> pq;
        vector<int> res(k);
        
        for (auto e : nums)
            hash[e]++;
        
        for (auto &e : hash) {
            pq.push(e);
            if (pq.size() > k)//<<<<We don't really need the heap larger than k. So, when it reaches the limit, keep dropping from it. Also not that, in this case, we need min heap, not max heap!!!
                pq.pop();
        }
        
        for (int i = 0; i < k; i++) {
            res[i] = pq.top().first;
            pq.pop();
        }
        
        return res;
    }
};

What's the time complexity? O (nlogk)

55. https://leetcode.com/problems/find-median-from-data-stream/

Here, you will need a min and max heap? What will be the condition of Cmp for min and max?

It would be:

struct CmpMin {
    bool operator()(int a, int b) {
        return a > b;
    }    
};

struct CmpMax {
    bool operator()(int a, int b) {
        return a < b;
    }    
};

class MedianFinder {
    priority_queue<int, vector<int>, CmpMin> pqmin;//<<<Note for min, we need to cheak greater (the opposite)
    priority_queue<int, vector<int>, CmpMax> pqmax;//<<<For max, we need to check smaller (the opposite)

56. https://leetcode.com/problems/design-twitter/

Here, it can be tempting to implememt tweets as:

unordered_map<int, list<pair<int, int>>> tweets;

This is because to find most recent 10 tweets, we need to access tweets like a linked list (get next node from current node). How would you implement the priority_queue then? 

I think that I would implement it as:

        priority_queue<pair<int, int>::iterator, vector<pair<int, int>::iterator>, Cmp> pq;
        
Problem with this approach is how would you if the iterator has reach the end?

You also need to store the person's id in the node so that you can get the list. Another approach would be not to use list. Implement your own Linkedlist. This is actaully better.

57. https://leetcode.com/problems/subsets/

How would you implemement this? 

Note that, if you keep another vector to keep track, that's not right (will get TLE); why? In backtarcaking, if you have a same node again, you should use memorization. For this, you should use each state a vector. This is how we can implement it.

struct HashFunc {
    int operator()(const vector<int> &v) const {//<<<See we can use vector as a key. Don't forget the const, otherwise it will not work. Also don't forget the reference. Otherwise it will not work. I often forget those
        long long sum = 0;
        
        for (auto e : v)
            sum += e;
        return sum;
    }    
};

class Solution {
    void subsets_inner(vector<int>& nums, 
                       unordered_set<vector<int>, HashFunc> &us, vector<vector<int>> &res) {
        int n = nums.size();
        
        if (us.count(nums))
            return;
        
        res.push_back(nums);
        us.insert(nums);
        
        if (n == 1)
            return;
        
        for (int i = 0; i < n; i++) {
            int tmp = nums[i];
            nums.erase(nums.begin() + i);
            subsets_inner(nums, us, res);
            nums.insert(nums.begin() + i, tmp);//<<<This is how you can insert inside a vector
        }
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> res;
        vector<int> valid(n);
        unordered_set<vector<int>, HashFunc> us;//<<<This is how you create a hash with custom function. YOu need 2 arguments, not 3
        
        res.push_back(vector<int>());//<<<This is how you can add an empty vector
        subsets_inner(nums, us, res);
        return res;
    }
};

58. What is the difference between queue and dequeue?

In deque, you add/delete from both front and back. In queue, you cannot delete from back. Note that, in queue, you have back() to access the back. But, you cannot delete it.

59. How to initilize an array?

class MyHashSet {
    const static int size = 100;//<<It has to be cosnt static. Only const will not work. Also define it inside the class
    Node *arr[size] = {NULL};//<<<You must initialize it. Ottherwise, it will have garbage value
public:
    MyHashSet() {
    }
    
60. What's wrong with the code?

struct HashFunc {
    int operator()(const pair<int, int> &p) const {
        return abs((p.first + p.second)) % 1000; //<<This will cause too many collision
    }  
};
unordered_set<pair<int, int>, HashFunc> visit;        

Better approach would be:


struct HashFunc {
    int operator()(const pair<int, int> &p) const {
        return abs((p.first * p.second)) % 10000000;//<<< The keys are more spreadout
    }  
};
unordered_set<pair<int, int>, HashFunc> visit;
        
61. https://leetcode.com/problems/minimum-knight-moves/

How would you implement this? 

Note that, there is a contstraint. How would you use that?

I tend to use BFS. If the any nodes we visit exceeds the constrants, I prune those nodes. But, it's not right. Search can go outside of the constrained space, but come back to map properly.

Will BFS scale? 

No.. I then also tend to consider A* search given my previous experience. But, can you do better? Bi-directional search!!!! Use bideirectional search instead of A* all the time!!! More intuitive.

I then implemented bi-direcrectional search. But, I was getting TLE. Then I realized that I was doing BFS less efficieently. In BFS, I add a node. Then in queue, I extract a node from the queue. I check if it's visited. If it's already visited, then continue. Otherwise, mark it visited. And then expand all the edges of the node by adding them to the queue. We can make it little more efficienet by checking if the new adjacent node is already visited. If it's not aready visited, then add it to the queue.

But, we can actually make BFS more efficient. When add the first node to the queue, also mark it visited before entering into the loop. In the loop, you simply extract the node, process it. Then add all the adjacent nodes to the queue if they are not already visited. Note that, when we are adding a node to the queue, we immemdiately mark it visited. So, we don't need to check if it's visited inside the top of the loop. The bidirectional search code is as follows:

struct Node {
    int x;
    int y;
    int level;
    Node (int x_, int y_, int level_) {
        x = x_;
        y = y_;
        level = level_;
    }
};

struct HashFunc {
    int operator()(const pair<int, int> &p) const {
        return abs((p.first * p.second)) % 10000;
    }  
};
class Solution {
    int arr[8][2] = {{-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}, 
                  {1, -2}, {2, -1}, {2, 1}, {1, 2}};
public:
    int minKnightMoves(int x, int y) {
        queue<Node> q1, q2;
        unordered_map<pair<int, int>, int, HashFunc> visit1, visit2;
        
        q1.push(Node(0, 0, 0));
        visit1[make_pair(0, 0)] = 0;//<<<mark it when adding to queue
        q2.push(Node(x, y, 0));
        visit2[make_pair(x, y)] = 0;//<<<mark it when adding to queue
        while (!q1.empty() && !q2.empty()) {
            Node n1 = q1.front();
            q1.pop();
            
            Node n2 = q2.front();
            q2.pop();
                                    //<<<Note that, here we don't need to check if the node it visited or not. We know that it's already visited bc when we add it, we immediately mark it visited.   
            auto it4 = visit2.find(make_pair(n1.x, n1.y));//<<<bi-directional search. Check if cur node is in other set
            if (it4 != visit2.end())
                return n1.level + it4->second;
            
            auto it5 = visit1.find(make_pair(n2.x, n2.y));//<<<bi-directional search. Check if cur node is in other set
            if (it5 != visit1.end())
                return n2.level + it5->second;
            
            for (int i = 0; i < 8; i++) {
                int to_add_x = n1.x + arr[i][0];
                int to_add_y = n1.y + arr[i][1];
                int to_add_level = n1.level + 1;
                auto itr = visit1.find(make_pair(to_add_x, to_add_y));
                if (itr == visit1.end()) {//<<<<When we add the children, we check if it's already visited, if not, we add to the queue and mark it visited immediately
                    q1.push(Node(to_add_x, to_add_y, to_add_level));
                    visit1[make_pair(to_add_x, to_add_y)] = to_add_level;//<<<<Marking it visited immediately
                }
            }            
            for (int i = 0; i < 8; i++) {
                int to_add_x = n2.x + arr[i][0];
                int to_add_y = n2.y + arr[i][1];
                int to_add_level = n2.level + 1;
                auto itr = visit2.find(make_pair(to_add_x, to_add_y));
                if (itr == visit2.end()) {//<<<<When we add the children, we check if it's already visited, if not, we add to the queue and mark it visited immediately
                    q2.push(Node(to_add_x, to_add_y, to_add_level));
                    visit2[make_pair(to_add_x, to_add_y)] = to_add_level;//<<<<Marking it visited immediately
                }
            }
        }
        return 0;
    }
}; 


Also, note how we implement bidirectional search. In every ieration, we need to check if the current node exists in other set. Sometimes, I mistakenly write a loop on all the nodes of a visit hash and check if any of the element exists in the other group. This is very unefficient and unnecessary.


Also note that, instead of using pair<int, int> as key, we can use string as a key (e.g. "0, 1"). That certainly makes code cleaner because you don't need to create custom hash. I thought I would get better performance with that. But, after trying, I didn't see performance improvement over pair<int, int>.

62. https://leetcode.com/problems/find-all-anagrams-in-a-string/

How would you implememt this?

In sliding window, I tend to think that, when we find a unmatch, we need to move start all the way to past end. But, that's not right. If we don't find a match, we should increase start one step only (if needed, look at my solution below). 

Also, when sliding window shoud stop? 

It should go until (end < size).

Here, in each iteration, check the end. If we find a match, then increase the end. Otherwise increase the start.

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int m = s.length(), n = p.length(), start = 0, end = 0;
        int hash[26] = {0};
        vector<int> res;
        
        for (int i = 0; i < n; i++) {
            hash[p[i] - 'a']++;
        }
        
        while (end < m) {//<<<See when sliding window should stop
            if (hash[s[end] - 'a']) {//<<< If we find a match, end should be incremeneted
                hash[s[end] - 'a']--;
                if (end - start + 1 == n) {
                    res.push_back(start);
                    hash[s[start] - 'a']++;
                    start++;
                    end++;
                } else {
                    end++;    
                }
            } else {//<<< If we don't find a match, start should be incremented
                hash[s[start] - 'a']++;
                start++; 
            }
        }
        return res;
    }
};        
        
63. https://leetcode.com/problems/coin-change/

How would you solve this?

Note that, it's easy to confuse backtracking with DP. DP is also a combinatorial optimization prolem. Sometimes, I wrongly think that the main difference between the two is that DP is an optimizaion problem whearas backtracking is not. But, that is not true. DP doesn't necessarily have to be optimization problem. For instance, counting all possible combination can also be DP. We will see soon. 

If a problem is a potential DP, try implementing in a bottom-up fashion. That leads to the solution usually.


DP can be only be applied if following two rules hold (typically you don't need to consider these while solving a problem): 

Overlapping subproblem
Principle of optimality - local oprtimal leads to gloabal optimal.


https://leetcode.com/problems/coin-change-ii/

How would you implement this?

Will backtacking work? Note that, in backtracking will produce same result multiple times. For intsance, if coins = {1, 2, 5} and amount = 6. In backtracking, it will produce
{1, 1, 1, 1, 2}, {1, 1, 1, 2, 1},... Problem is the are the same. So, backtracking doesn't work if multiple solution with different order actaully mean the same solution. One way to solve this is to store the result and check if a result is already added. However, this can be a very expensive solution because you need to sort the result before checking. Can you do better?

Yes, this is also a DP. This is an example of DP which is not an optimization problem.

How would you formulate it in bottom-up fashion? Note that, if you do bottom up on amount, it will not work because it will include same solution multiple times? How about bottom-up on coin array. Add one coin at a time.

Try formulatimng the DP. I found it really hard!!!

64. https://leetcode.com/problems/word-break/

How would you implemement this?

How would you handle word ="aaaaab", dictionary = ["a", "aa", "aaa", "aaaa"]?

If you can't figure out, see my own solution.
        
64. Consider following class

class Node{
public:    
    unordered_map<char, Node*> child;
    bool is_leaf;
};        

Do you need to define a constructor? Do you need to set the boolean to false erxplicitly?

No, if don't need to define a constructor. Compiler will provide a constructor for you.

You also don't need to set the boolean to false. It will be set to false by compiler.

65. https://leetcode.com/problems/max-stack/

How would you implement this?

One approach can be delayed delete. Another approach can be balanced binary tree (both are mentioned in the leetcode solution). 

Balanced binary tree (e.g. red-black tree) is a good solution if you want to keep elements in sorted order. It allows us log(n) lookup. Insert and delete is also log(n) + balancing cost(fixed).

We can implement balanced tree using map. This is how to use map:

int main()
{
    // Ordered map
    std::map<int, int> order;
 
    // Mapping values to keys
    order[5] = 10;
    order[3] = 5;
    order[20] = 100;
    order[1] = 1;
 
    // Iterating the map and
    // printing ordered values
    for (auto i = order.begin(); i
         != order.end(); i++) {
        std::cout << i->first
                  << " : "
                  << i->second << '\n';
    }
}

Output:

1 : 1
3 : 5
5 : 10
20 : 100

//<<<<<Note that keys are kept sorted.

If you need the largest key, you can access by map.rbegin()

How to delete elements in map?

int main ()
{
  std::map<char,int> mymap;
  std::map<char,int>::iterator it;

  // insert some values:
  mymap['a']=10;
  mymap['b']=20;
  mymap['c']=30;
  mymap['d']=40;
  mymap['e']=50;
  mymap['f']=60;

  it=mymap.find('b');
  mymap.erase (it);                   //<<<< You can erase by iterator

  mymap.erase ('c');                  //<<<<< You can erase by key

  it=mymap.find ('e');
  mymap.erase ( it, mymap.end() );    //<<<< You can erase by range

  // show content:
  for (it=mymap.begin(); it!=mymap.end(); ++it)
    std::cout << it->first << " => " << it->second << '\n';

  return 0;
}

Note that, keys of map are unique. You cannot have same key with mutiple times. If you need same key twice, you will need multimap which is similar to map. Example taken from Dr. Nesterenko's example:

int main () {
   multimap<char,int> myMM; //<<<<<<You can declare a multimap like a map
   srand(time(nullptr));

   for(int i=0; i < 10; ++i)
      myMM.insert(make_pair('a'+ rand()%5, rand()%100));//<<<<You need to use this approach. [] operator will not work 

   // myMM['a']=55; //<<<<< not allowed
   
   // print content
   cout << "elements in myMM:" << endl;
   for(const auto& e: myMM) //<<<<You can iterate multiplemap like a map
      cout << e.first << "\t" << e.second << endl;

   /*
   
   cout << "all elements in myMM with key 'a'" << endl;
   for(auto it=myMM.lower_bound('a'); it != myMM.upper_bound('a'); ++it) ///<<<<<If you weant to iterate the all the keys associated with a key, use this approach
      cout << it->first << '\t' << it->second << endl;

   */
   auto it = myMM.find('a');//<<<<If we want to delete only one <key, val> at a time, use following approach
   
   while (it != myMM.end()){
      cout << "erasing " << it->first << '\t' << it->second << endl;
      myMM.erase(it);//<<<<If we want to delete only one <key, val> at a time, use following approach
      it = myMM.find('a');//<<<<If we want to delete only one <key, val> at a time, use following approach
   }

   
   // erasing all elements with key 'b'
   cout << myMM.erase('b') << endl;//<<<< Note that this will delete all the <key, val> with key 'b'
   
   
   myMM.erase(myMM.lower_bound('c'), myMM.upper_bound('c'));//<<<< Note that this will delete all the <key, val> with key 'b'
   
   // print content
   cout << "elements in myMM:" << endl;
   for(const auto& e: myMM) 
      cout << e.first << "\t" << e.second << endl; 
   
}        



Now, see how we are solving https://leetcode.com/problems/max-stack/. Note that, this is bit different from leetcode solution. I think, this makes more sense


class MaxStack {
    map<int, int> ordered_elemets;
    multimap<int, int> max_elements;
    int idx;
public:
    MaxStack() {
        idx = 0;
    }
    
    void push(int x) {
        ordered_elemets[idx] = x;
        max_elements.insert(make_pair(x, idx));
        idx++;
    }
    
    int pop() {
        auto it = ordered_elemets.rbegin();
        int idx = it->first;
        int val = it->second;
        auto itr = max_elements.upper_bound(val);
        --itr;
        max_elements.erase(itr);
        ordered_elemets.erase(idx);
        return val;
    }
    
    int top() {
        return ordered_elemets.rbegin()->second;
    }
    
    int peekMax() {
        return max_elements.rbegin()->first;
    }
    
    int popMax() {
        auto it = max_elements.rbegin();
        int val = it->first;
        int idx = it->second;
        auto itr = max_elements.upper_bound(val);
        --itr;
        max_elements.erase(itr);
        ordered_elemets.erase(idx);
        return val;
    }
};

66. https://leetcode.com/problems/wiggle-sort-ii/

How would you implement this?

I typically sort this. Then merge one left half and right half. If you do that, you will not get right result. For instance, for [4, 5, 5, 6], result would be [4, 5, 5, 6] which is not right. Right result would be [5, 6, 5, 5]. How can you achieve that output?

I tried to find a different algorithm, but couldn't find. But, note that you have following situation:

               C
     B    B

A 

To make it to work, you need to make it to:


     C
B              B

         A
         
So, acoording to that, my solution was:

class Solution {
public:
    void wiggleSort(vector<int>& nums) {
        int n = nums.size(), secord_part_size = n/2;
        vector<int> res(n);
        
        sort(nums.begin(), nums.end());
        for (int i = 0, j = n - secord_part_size, k = 0; k < n; i++, j++) {
            res[k++] = nums[i];
            if (k < n)
                res[k++] = nums[j];
        }

        for (int i = 1; i < n; i++) {
            if (res[i] == res[i-1]) {//<<<Rearranging if two consecutive elements are the same.
                int a1 = res[i-2];
                int a2 = res[i];
                int a3 = res[i+1];
                res[i-2] = a2;
                res[i-1] = a3;
                res[i] = a1;
                res[i+1] = a2;
                i = 0;///After doing it, start over because doing so can cause create the same problem elsewhere
            }
        }

        nums = res;
    }
};         

67. https://leetcode.com/problems/maximum-subarray/

How would you implement this? Note that, this is typical DP problem, bause this is a typical combinatorial optimization problem. We can simply solve it via:



--------------------
|  A  |   B  |  C  |
...................-
|     |   B  |  C  |
--------------------
|     |      |  C  |
--------------------

But, can we do better?

If you can't find the solution by yourself, look at the solution (either my solution or leetcode solution)

68. What if you are asked to write a simple main function in C++?
#include <iostream>
#include <string>



#include <iostream>//<<<
#include <string>
#include<algorithm>//<<<Note that, this is not <algorithms>. This includes STL algorithms. This doesn't include STL data structures like vector, list, etc. You will need to include them sdeparately
#include <vector>//<<<You need to include them separately (I mistakenly think that including algorithm includes it, but that's not right)
#include <fstream>//<<< This is needed for file operatij
#include <bits/stdc++.h>//<<<This is needed for INT_MAX,...

using std::cout;//<<<Declare each using separatly. Otherwise clang++ will produce warning
using std::string;//<<<Declare each using separatly. Otherwise clang++ will produce warning
using std::endl;//<<<Declare each using separatly. Otherwise clang++ will produce warning
using std::vector;
using std::max;//<<<Note that, this is std::max()

//using std::cout;using std::string;using std::endl;//<<<Dr.Nesterenko uses them in the same line. This is preferred

int max_value(string s) {
  return 1;
}

int main() {
  string s = "1*3+3*5+5+5*6";
  cout << max_value (s) << endl;
}

To compile: clang++ -std=c++11 <filename> //<<<<Use clang++


69. https://www.geeksforgeeks.org/minimum-maximum-values-expression/

How would you solve this?

I know that this is Matrix chain multiplication problem. But, I don't remember how the problem is solved. I can view this as a typical combinatorial optimization problem. So, I may think that I will consider only one operator first. Then only 2 operators, then only 3 operators....finally all the operrators. So, I can build a DP array like:

--------------------
|  A  |   B  |  C  |
...................-
|     |   B  |  C  |
--------------------
|     |      |  C  |
--------------------

Here, I need to calculate the elements diagonally. I mistakenly implement in row/column-wise travarsal which gives me wrong result.

I also make another big mistake. I calculate dp[i][j] based on dp[i][j-1] and dp[i+1][j]. But, it will not work. This will skip lots of possible solution space. Why? It means, for intsance, you are calculating dp[0][5] based on dp[0][4] and dp[1][4]. But, there are many other ways you can break dp[0][4]. 

For instance, you can calculate [0, 4] based on:

1. [0,0] [1,4]
2. [0,1] [2,4]
3. [0,2] [3,4]
4. [0,3] [4,4]

So, Yes, matrix chanin multiplication problem as a combinatorial optimization problem, but, you cannot simply calculate it based on dp[i][j-1] and dp[i+1][j]. For each entry, you need an inner loop to check all possible ways to break the range. Now, how would you implement this?

If you try to implemement an inner loop, you will see another problem. If you try to break by operator, you one operand will be in both part. So, you can't really btreak by operator. 
You need to break by operand. So, formulate using operand as before. Note that, you will need an inner loop. The code looks like:

int eval (int a, char op, int b) {
  return (op == '+') ? a + b : a * b;
}

int max_value(string s) {
  vector<int> operands;
  vector<char> operators;
  
  for (int i = 0, start = 0; i < s.length(); i++) {//<<<Parsing string into numbers and operators. Note that parsing string is not difficult at all
    if (!isdigit(s[i])) {
      operands.push_back(atoi(s.substr(start, i - start).c_str()));
      operators.push_back(s[i]);
      start = i + 1;
    } else if (i == s.length() - 1) {
      operands.push_back(atoi(s.substr(start).c_str()));
    }
  }
  
  int n = operands.size();
  vector<vector<int>> dp(n);
  
  for (auto &e : dp)
    e.resize(n);

    
  for (int i = 0; i < n; i++) {//<<<<<Initialize the diagonal as the operand
    dp[i][i] = operands[i];
  }
  
  for (int m = 1; m < n; m++) {//<<<<Iterarate over each diagonal
    for (int i = 0, j = m; j < n; i++, j++) {//<<<<Iterarate over each diagonal
      dp[i][j] = INT_MIN;
      for (int k = i, m = i + 1; k < j; k++, m++) {//<<<<Check all possible way to break it
        int e = eval (dp[i][k], operators[k], dp[m][j]);
	dp[i][j] = max(dp[i][j], e);
      }      
    } 
  }   
  
  return dp[0][n-1];
}

Note that, I created the solution without looking into Matrix chanin multiplication solution. Here, I simply tried to formulate the problem in a bottom up manner and it works.

What is the differnece between this problem and https://leetcode.com/problems/maximum-subarray/?

Even if we implemented maximum-subarray as 2D DP array (which is unefficient and there is a better way), there we needed to iterate over all possible subset. So, we didn't need the inner loop. On the other hand, in this problem, we needed to break the solution in all possible ways. So, we needed inner loop. I think, this is the essense of matrix chain multiplication problem.


Later, I checked the solution of this problem and matrix chain multiplication problem from geeksforgeeks. They are also using the same approach. So, no need to travarse the array in row/column fashion. Travarse it in diagonal fashion!!!!



70. https://leetcode.com/problems/group-anagrams/

How would you implement this?

Note that, here you can sort the string because strings with different string lengths doesn't need to be checked. How can you sort the array of string based on string length?

        sort(strs.begin(), strs.end(), [](string &s1, string &s2) {
            return s1.length() < s2.length();
        });
      
But, do we really need to sort the string? We can use frequency array as key in a hash:

struct HashFunc {//<<<<<It should be struct. If you declare it as class, it will not work.
    int operator()(const vector<int> &v) const {//<<<Note that we need make it cost for hash. Cost is not needed for writing CmpFunc for priority_queue
        int sum = 0;
        
        for (auto e : v) {//<<<Hash function can be as trivial as this. This will work. But, results may not be the best
            sum += e;
        }
        return sum;
    }    
};

class Solution {
    vector<int> calc_key(string s) {
        vector<int> freq(26);
        
        for (int i = 0; i < s.length(); i++) {
            freq[s[i]-'a']++;
        }
        return freq;
    }
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res;
        unordered_map<vector<int>, vector<string>, HashFunc> hash;//<<<<<<Frequency of the characters as hash. We can use a vector as key.
        
        for (auto &e : strs) {
            vector<int> key = calc_key (e);
            hash[key].push_back(e);
        }
        
        for (auto it = hash.begin(); it != hash.end(); it++) {
            res.push_back(it->second);//<<<<You can add vector<string> in push_back
        }
        return res;
    }
};


71. https://leetcode.com/problems/decode-ways/

How would you implement this?

You will think of recursion....Now, think, if you can solve it in a bottom up (DP) manner. You will see that it's possible. Everytime you solve something using recursion, think if you can solve it using bottom-up manner (DP). DP implementation is usually cleaner and less error prone.

Also, note that this is not an optimization problem. This is more like a combinatorial problem, but still DP can be applied.

If you can't figure out the solution, look at my own solution.

72. https://leetcode.com/problems/sort-an-array/

How would implement this?

You can use quick sort or merge sort? How would you implememt both approach?

What is the run time of quick sort?

No, it's not O(nlogn). It's O(n^2). Why? If your pivot is really the smallest element of the the array, it will call quick sort for rest of the element. It will not divide the array into two almost equal part. So, worst case run time for quick sort is O(n^2), but average case run time is O(nlong).

If you want quarnteed O(nlogn), you need to implement merge sort.

But, try to implement this problem in both quick sort and merge sort (although quick sort will get TLE. Note that, you can check if the array is already sorted, and skip it altogether sorting. I tried that with quick sort. It still gets TLE. It's because if the array is mostly sorted, it will also result in poor performance.)

For quick sort, how would you implement partition?

I generally think like this. I will take first element as pivot. Then I would have two index, i = start + 1, j = end. Then I use two pointer approach. Any time, I find two elements one is bigger than pivot and another is smaller than pivot, I sawp them. Then I put the pivot to actual position. So, the implementation looks like:

    void sortArray(vector<int>& nums, int start, int end) {
        int pivot = start, s = start + 1, e = end;
        
        while (e > s) {
            while (s <= e && nums[s] < nums[pivot])
                s++;
            while (e >= s && nums[e] > nums[pivot]) {
                e--;
            }
            
            if (e > s) {
                swap(nums[s++], nums[e--]);
            }
        }
        swap(nums[pivot], nums[s]);
        sortArray (nums, start, s - 1);
        sortArray (nums, s + 1, end);
    }

But, this will not work. //<<<<<<<<This is not the right way to implement two pointer approach. In two pointer, we should only update start/end only once in each iteration.

I saw different ways to implememt partuition. They both use one and two pointer approach. For instance, this is a one pointer approach to do partition:

https://www.geeksforgeeks.org/quick-sort/

Based on the concept, I implememented, my own one pointer approach to partition, but it gets TLE. It's as following:

    void sortArray(vector<int>& nums, int start, int end) {
        int pivot_idx = start, idx_to_replace = start;
        
        if (end - start + 1 == 2) {
            if (nums[end] < nums[start]) {
                swap (nums[end], nums[start]);
            }
            return;
        }
        
        if (end - start + 1 < 2)
            return;
        
        for (int i = start + 1; i <= end; i++) {
            if (nums[i] < nums[pivot_idx]) {
                swap (nums[i], nums[idx_to_replace]);
                if (idx_to_replace == pivot_idx) {
                    pivot_idx = i;
                }
                idx_to_replace++;
            }
        }
        swap(nums[idx_to_replace], nums[pivot_idx]);
        sortArray (nums, start, idx_to_replace - 1);
        sortArray (nums, idx_to_replace + 1, end);
    }
    
    
Note that, two pointer is more efficient than than one pointer approach because in one pointer approch, you may need to swap a node to pivot which actually in the right partion anyway, so not needed to be swapped. Two pointer approach actually makes more sense here.

Note that, in two pointer, implement in a way that only low or high index is updated at most once in each iteration.////<<<<<<<<<<<<<<<<<    

    void sortArray(vector<int>& nums, int start, int end) {
        if (end <= start)
            return;
        int pivot = nums[start];
        int low = start + 1, high = end;
       
        while (low < high) {///<<<<<<< Note, as we update index at a time, when low == high, we can immediately stop.
            if (nums[low] < pivot) {
                low++;
            } else if (nums[high] > pivot) {
                high--;
            } else {
                swap (nums[low], nums[high]);
                low++;
                high--;
            }
        }
        if (nums[low] > pivot)
            low--;
        swap (nums[start], nums[low]);
        sortArray (nums, start, low - 1);
        sortArray (nums, low + 1, end);
    }
    
    
But, as mentioned earlier, quick sort isn't the right solution for this problem.

How would you implemengt merge sort? If you can't remember, look at my own solution.   


72. https://leetcode.com/problems/search-in-rotated-sorted-array/

How would you implement this?

Here, I mistakenlt plot the points as:


         A
       A
    A 
  A
A             
              A
                A
                  A
                  
Actually, the plot should be:

         A
       A
    A 
  A
A         
    
            A
          A
        A 
        
Now, you can see that there are two segments. I still had hard time formulating binary search for it.

If start and end are in one segment, it's like ordinary binary search. But, if start and end span two line segments, then it's complicated. How would you formulate the condition? I tend to only consider mid, and based on that, I try to make a decision. That's wrong. There is another important criteria: target. So, there can be following situation:

mid                    target
-------------------------------------
first part             first part
first part             second part
second part            first part
second part            second part  

Now you can formulate the binary search.


73. https://leetcode.com/problems/jump-game/

How would you implement this?

BFS would work. Where would you check if you have reached the last index? 


class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size(), cur;
        queue<int> q;
        vector<int> visit(n);
        
        if (n == 1)
            return true;
        
        visit[0] = 1;
        q.push(0);
        while (!q.empty()) {
            cur = q.front();
            q.pop();
            //if (cur == n - 1)////<<<<<<<Doing this causes TLE
            //	return false;
            for (int i = 1; i <= nums[cur]; i++) {
                int to_jump = i + cur;
                if (to_jump == n - 1)///<<<<<<This is the right place to check
                    return true;
                if (to_jump < n && !visit[to_jump]) {
                    q.push(to_jump);
                    visit[to_jump] = 1;
                }
            }
        }
        return false;
    }
};

74. https://leetcode.com/problems/longest-common-subsequence/

How would you implement this?

I tend to go for backtracking. But, do you really need backtracking? To get all possible sub string, you can use loops as:

class Solution {
    bool isPalindrome(string s) {
        int i = 0, j = s.length() - 1;
        
        for (; i < j; i++, j--) {
            if (s[i] != s[j])
                return false;
        }
        return true;
    }

public:
    int countSubstrings(string s) {
        int count = 0, n = s.length();
                
        for (int i = 0; i < n; i++) {///<<<<<<<<<Finding all possible substring
            for (int j = i; j < n; j++) {///<<<<<<<<<Finding all possible substring
                if (isPalindrome (s.substr(i, j - i + 1)))
                    count++;
            }
        }
        return count;
    }
};

75. https://leetcode.com/problems/longest-common-subsequence/

How would you implement this? I know that this is DP. But, think, how would you implement it without DP?

This seems like applying backtracking on both string and check equality in each stage. This seems like extremely complicated alogirithm without DP. But, DP can help us to solve it very easily. Note that, if you encounter similar problem, it's likly to be DP as well.

How would you implement it in DP? In DP, try to solve any problem in bottom up manner. If you can't, try to solve larger problem from smaller problem. I was able to solve it owbn my own without looking at the solution.

76. https://leetcode.com/problems/edit-distance/

How would you implement this? I know that this DP. If I had to implement it other than DP, I had to use backtracking. So, similar problem can be implemented by DP.

How would you formulate it in DP?

Try to solve it in a bottom up fashion or try to solve larger problem from smaller problem. I was able to formulate DP without looking at the solution.  

76. Note that, following will not work.

int arr[] = {3, 4, 4, 6};

It should be:

int arr[4] = {3, 4, 4, 6};

Also, C++ doesn't have exponent operator. So, following would not work:

int a = 2^i;

It should be:

int a = pow (2, i);


77. https://leetcode.com/problems/gray-code/

How would you implement this? If can't figure, look at the leetcode solution and my solution.

78. If you define a constructor in C++, do you still implement deafult constructor to use it?

Yes, if you define a constructor, compiler will no longer provide the deafult constructor. For instance, following will not work:

 Class Test{
    int a;
    int b;
    Test (int a_, int b_) {
      a = a_;
      b = b_;
    }
 }
 
 Test t;//<<<It will invoke deafult constrctor which doen't exist.
 
 Following will work:
 
  Class Test{
    int a;
    int b;
    Test () {//<<<<You need to define default constructor manually
      a = 0;
      b = 0;
    }
    Test (int a_, int b_) {
      a = a_;
      b = b_;
    }
 }
 
 Test t;
 
 
 79. How to append one vector 'b' to vector 'a'? Vector 'a' can be empty or non empty.
 
 a.insert(a.end(), b.begin(), b.end());//<<<This will append 'b' to the end of 'a'. This will work even if 'a' is empty.
 
 80. https://leetcode.com/problems/rectangle-area/
 
 How would you implement this? If you can't figure out, take a look my own solution. There the idea is:
 
 Here, main question is how can you find the points of intersection rectangle?
 
 If a rectangle is like, how would you calculate the intersection point?
 
          ----------------
          |               |
          |               |
 -------------------      |
 |        |        |      |
 |        |        |      |
 |        ---------|-------
 |                 |
 ------------------
 
Bottom left of intersection would be: <max (ax1, bx1), max (ay1, by1)> (take maximum of the lower left)
Top right of intersection would be: <min (ax2, bx2), min (ay2, by2)>  (take minimum of upper left)

Now, will this work for other situation?

I found that the same rule holds if the rectangles are positioned differently. So, we can use the formula.


81. https://leetcode.com/problems/maximum-product-subarray/

How would you implement it?

Also, when can you implement combinatorial optimization using to a nested loop?

Think about the following loop.

        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                cout << "i = " << i << " j = " << j << endl; 
            }
        }
It will produce something like:

--------------------
|  A  |   B  |  C  |
...................-
|     |   B  |  C  |
--------------------
|     |      |  C  |
--------------------

So, you can use the for loop a get all the subset of size 1, 2, 3...n. So, in those cases, you can use for loop for creating subset.

I often try to solve https://leetcode.com/problems/maximum-product-subarray/ as follows. But it gets TLE!!!!

class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int res = INT_MIN;
        int n = nums.size();
        int prod;
        
        for (int i = 0; i < n; i++) {
            prod = nums[i];
            res = max (prod, res);
            for (int j = i + 1; j < n; j++) {
                prod *= nums[j];
                res = max (res, prod);
            }
        }
        
        return res;
    }
};        

Can you do it at O(n)? Then answer is probably you can and the answer would be DP, because this is a combinatorial optumization problem. Note that, the previous solution already looks like a DP bacuse it's creating a 2D array and checking all possible combination. How can you make it O(n) DP?

If you can't figure out, note that, in DP, we calculate the solution in bottom up manner. So, try to visualize how the bottom up solution will look like. Visualize how the final solution can be calculated based on smaller solution. If still can't figure out, look at my own solution.

82. https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/

How would you implement this?

At first, I think, I would use recursivly make pointers of childer to chield of children as:

class Solution {
    void connnect_sibling(Node* n1, Node* n2) {
        Node *a, *b;
        
        if (!n1)
            return;
        n1->next = n2;
        
        queue<Node*> q;
        if (n1 && n1->left)
            q.push(n1->left);
        if (n1 && n1->right)
            q.push(n1->right);
        if (n2 && n2->left)
            q.push(n2->left);
        if (n2 && n2->right)
            q.push(n2->right);
        
        while (q.size() > 1) {
            a = q.front(); 
            q.pop();
            b = q.front();
            connnect_sibling (a, b);
        }
    }
public:
    Node* connect(Node* root) {
        if (!root)
            return root;
        connnect_sibling (root->left, root->right);
        return root;
    }
};

But, this will not work!! This is because a child of a node may need to point to children of cousin. The above code will work for pointing to child of of siblings, but not for cousines. Now, how can you implement this?

Level order travarsal...      

83. Suppose, you need to implement vector<pair<index(int), freq(int)>>. You need to sort it. How would you implement that?

Instead of doing that, we can create another array of indices and sort that array based on the freq as:

        vector<int> freq(n);//<<<<Actual frequncy
        vector<int> indices(n);//<<<Create an additional array
        
        for (int i = 0; i < n; i++) {//<<<<Set the indices
            indices[i] = i;
        } 

        sort(indices.begin(), indices.end(), [&](int a, int b) {//<<<Sort the indices based on the freqency
            return freq[a] <= freq[b];
        });

84. https://leetcode.com/problems/minimum-height-trees/

How would you implememt this?

Here, I think of using map<int, int> where each entry contains the frequency. I do this because I want to access the most frequent node first, then next most frequent and so on. So, will this work? 

No!!! map<int, int> keeps key-value pairs sorted on key, not the value!!!!!! Here, I need access element in the order of their frequency. So, what can we do?

We can simply sort them. So, I implemented as the below code. Here, the idea is most frequent node would be the root. But, later we found out that approach will not work. For instance, in the following graph, 3 should be the root, although most frequent node is 0. So, following code will not work.

       0
     / | \
    1  2  3
          |
          4
          |
          5
class Solution {
    int calc_height(vector<vector<int>> adj_list, int root) {
        unordered_set<int> s;
        queue<pair<int, int>> q;
        pair<int, int> cur;
        int height = 0;
        
        q.push(make_pair(root, 0));
        s.insert(root);
        while (!q.empty()) {
            cur = q.front();
            q.pop();
            for (auto e : adj_list[cur.first]) {
                if (s.count(e))
                    continue;
                q.push(make_pair(e, cur.second + 1));
                s.insert(e);
                height = max (height, cur.second + 1);
            }
        }
        return height;
    }
public:
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        vector<int> freq(n);
        vector<int> indices(n);
        vector<vector<int>> adj_list(n);
        vector<int> res;
        
        for (int i = 0; i < n; i++) {
            indices[i] = i;
        }
        
        for (auto &e : edges) {
            freq[e[0]]++;
            freq[e[1]]++;
            adj_list[e[0]].push_back(e[1]);
            adj_list[e[1]].push_back(e[0]);
        }
        
        sort(indices.begin(), indices.end(), [&](int a, int b) {
            return freq[a] >= freq[b];
        });
        
        
        int max_freq = indices[0];
        int max_freq_node = 0;
        for (int i = 1; i < n; i++) {
            if (freq[i] > max_freq) {
                max_freq = freq[i];
                max_freq_node = i;
            }
                
        }
        
        int h = calc_height (adj_list, indices[0]);
        res.push_back(indices[0]);
        
        for (int i = 1; i < n; i++) {
            if (calc_height (adj_list, indices[i]) == h)
                res.push_back(indices[i]);
        }
        
        return res;
    }
};


So, how can we implememt this. I then used brutforce approach and calculate tree-height for each node. We store the node and height in a priority_queue. That approach gets TLE.

What would be the algorithm to find the root for MHT?

85. Sometimes, I need to use queue of pairs. Code as following: it makes it simpler.

class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<pair<TreeNode*, int>> q;
        vector<int> res;
        int level;
        TreeNode* n;
        
        if (!root)
            return res;
        
        q.push(make_pair(root, 0));
        while (!q.empty()) {
            n = q.front().first;//<<<<Store the first and second to actual variable so that it makes more sense.
            level = q.front().second;//<<<<Store the first and second to actual variable so that it makes more sense.
            q.pop();
            .....
    }
};

86. How would you generate random number?

        srand(time(nullptr));///<<<<I forget about "time(nullptr)"
        int rand_num = rand() % size; ///<<<< I forget that rand() generates a random number between 0 and RAND_MAX
        
These are taken from Dr. Nesterenko's example.


87. How can you advance an iterator?

For instance, following doesn't work
	unordered_set<int> us;
        auto it = us.begin();
        it = it + idx;//<<<This will get compilation error.

The solution is to use std::advance().
        auto it = us.begin();
        advance(it, idx);///<<<This will work. Note that, this is not "it.advance(idx)". I sometimes mistakenly think so.
        
87. https://leetcode.com/problems/insert-delete-getrandom-o1/

How would you implemement this?

class RandomizedSet {
    unordered_set<int> us;
public:
    RandomizedSet() {
        srand(time(nullptr));//<<<<It has to be done only once. Doing this inside getRandom() will cause producing the same # again and again
    }
    
    bool insert(int val) {
        if (us.count(val) == 0) {
            us.insert(val);
            return true;
        }
        return false;
    }
    
    bool remove(int val) {
        if (us.count(val)) {
            us.erase(val);
            return true;
        }
        return false;
    }
    
    int getRandom() {
        int size = us.size();
        int idx = rand() % size;///<<Get random number
        auto it = us.begin();
        advance(it, idx);///<<< advancing iterator
        return *it;
    }
};

88. In class, you can define multiple members in the same line:

class ZigzagIterator {
    int idx1, idx2, m, n;//<<<<<<This is perfectly valid
    bool first;
    vector<int> _v1, _v2;//<<<<<<This is perfectly valid
};

89. https://leetcode.com/problems/zigzag-iterator/

How would you store the vector inside your class? Would you define as a refernce or object?

You need to define as object as:

class ZigzagIterator {
    int idx1, idx2, m, n;
    bool first;
    vector<int> _v1, _v2;
public:
    ZigzagIterator(vector<int>& v1, vector<int>& v2) {
        idx1 = 0;
        idx2 = 0;
        m = v1.size();
        n = v2.size();
        first = m > 0;
        _v1 = v1;
        _v2 = v2;
    }
}

Note that, if you define as reference, you will get compilation error. 

Isn't creating multiple copies of the vector expensive?

Here, we are not actually creating a new copy of the vector. _v1 and _v2 will point the actual vector. If you change _v1 or _v2, actual vector will be changed. So, even though we are defineing an object in class, we are not creating separate copies.
The class will need to create a separate copy of the vector            
        
90. https://leetcode.com/problems/multiply-strings/

How would you implement this?

I tend to use in ordernary integer fashion. But, note that, this will cause overflow even after using "long long". Right way to implement the logic keeping everything in string.

91. https://leetcode.com/problems/serialize-and-deserialize-bst/

How would you implememnt this?

If you can't figure it out, look at my own solution.

92. https://leetcode.com/problems/detect-cycles-in-2d-grid/

How would you implement this?

DFS. How would you implement DFS?

It seems that I was doing DFS inefficiently. Think about the graph. For instance, you start with A. Then you will visit B for instance. From B, you can visit C or A. How would you prevent from visit A from B? 

  B----C
 /      |
A-------D

YOu will mark A visited. But, that will not work, because at some point in D, you will come accross A again. How would you differentiate if it's cycle or you are just getting back from B?

The trick is, for un-directed graph, you also need to keep track of the node you are visiting from. For instance, when visiting B, you also need to pass that it's coming from A. That way, it will know that, it should not visit A from B.




You start with A. 

93. https://leetcode.com/problems/regular-expression-matching/

How would you solve this problem?

You can implement it using recursion. But, there will be many common sub-problem. So, you can use memorization or DP. So, DP is clearly a good candidate. This problem is lot like edit-distance problem. But the difference is, I knew that edit distance can be solved using DP. But, I didn't know for sure if this problem can be solved using DP.

Now, there are two problems:

1. Is this really a DP?
2. How would you formulate DP?

Let's first assume that it's a DP. That is, I will try to solve the prblem using bottom-up approach. I was able to do that without looking at the solution.

How do you formulate it?

It was not very clear in the beginning. In many problem, I try to visualize how top-down solution works on paper. From there, I can have a hint on how bottom-up solution would look like. Then, I just draw a DP table and see if I can formulate the problem there. If I can, I got it.

94. How to delete all the consecutive '*' in a string?

        for (int i = 1; i < p.length();) {
            if (p[i] == '*' && p[i-1] == '*')
                p.erase(i, 1);
            else
                i++;    
        }
This is taken from Dr. Nesterenko's approach.

94. https://leetcode.com/problems/wildcard-matching/

How would you implememt this?

If you think, it's a recursion and likely be a DP problem like edit distance. How can you be sure if it's a DP and how to formulate the DP? 

I was able to solve this without looking at the solution. First. I thought of how top-down approach will work. Then I had an idea how bottom up approach will work. Then I created a DP array and tried to solve the propblem on paper using DP table. If I can formulate on the table, then it's DP problem (no need to think about principle of optimality and overlapping subproblem).

95. https://leetcode.com/problems/course-schedule/

How would you implement this?

I can implement this using checking cycle in DFS. However, implementing DFS can be much trickier sometimes. On the other hand. BFS is generally simple.

For instance, in https://leetcode.com/problems/detect-cycles-in-2d-grid/ I had to implement DFS to detect the cycle in an undirected grapph. There the issue was how to you prevent DFS to go back to the previous node, because it's undirected graph. I carefully used direction there. Based on the direction, I don't go to the node where I came from.

Now, we have a directed graph. So, we don't have that problem. Also, I used to implement DFS like a backtrcking solution where I don't return the result. This is not right. You can actually return the result. I found not retrurning the result is more easy, but it may lead to less readable code. So, return the result instaed as:

class Solution {
    bool is_cycle (int numCourses, vector<vector<int>> &adj_list,
              vector<bool> &visit, vector<bool> &path, int a) {//<<<<<<<<<<
        bool ret = false;
        path[a] = true;
        visit[a] = true;
        
        for (auto &e: adj_list[a]) {
            if (visit[e])
                return true;
            ret = is_cycle(numCourses, adj_list, visit, path, e);
            if (ret)
                break;    
        }
        visit[a] = false;
        return ret;
    }
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> adj_list(numCourses);
        vector<bool> visit(numCourses, false);
        vector<bool> path(numCourses, false);

        for (auto &e : prerequisites) {
            adj_list[e[1]].push_back(e[0]);
        }

        for (int i = 0; i < numCourses; i++) {
            if (!path[i]) {
                if (is_cycle(numCourses, adj_list, visit, path, i))//<<<<DFS
                    return false;
            }
        }
        return true;
    }
}; 



Now DFS in directed graph has own set of challenges. In DFS, we simply mark a node visited and call DFS on its adjacent nodes. Now, will this work for following graph?

     
   -->b------>C------>d
  /                   ^
 /                    |
/                     |   
a-------------------->e


Here, we will visit a, b, c, d and mark them visited. Then we will visit a, e and d and mistakenly call it cycle. But, it's not a cycle.


To solve this prolem, when we backtracking from a node, we will mark it unvisited again. That way, when it visits a, e , d, it will not result in mistaken cycle. The code will look like:

    bool is_cycle (int numCourses, vector<vector<int>> &adj_list,
              vector<bool> &visit, int a) {
        bool ret = false;
        path[a] = true;//<<<<<<<<<<
        
        for (auto &e: adj_list[a]) {
            if (visit[e])
                return true;
            ret = is_cycle(numCourses, adj_list, visit, path, e);
            if (ret)
                break;    
        }
        visit[a] = false;//<<<<<<<<
        return ret;
    }


Now, this approach has another performance problem. Think about the graph:


      ------------------
      |                |
      |                |
      |                v
a---->b------->c------>d         e
      |        |                ^ ^
      |        |                | |
      |        ------------------ |
      |                           |
      -----------------------------        
      
Here, we will visit a, b, c, d , backtrack, e, backtrack, backtrack, d, backtrack, e  

So, note that we are visiting d and e multiple times unncessarily. This causes TLE. But, if we mark a node unvisited, we have no way of knowing if we visited it before.


So, solution is, don't mark it unvisited when backtrack. Instead mark it as a differet color. When visit node for the first time, mark it as 1. When backtracking from the node, mark it as 2. That way, we can distingush beteen the two situation. The code should look like:

    bool is_cycle (int numCourses, vector<vector<int>> &adj_list,
              vector<int> &visit, int a) {
        bool ret = false;
        visit[a] = 1;  ///<<<<< mark it 1 for the first time
        
        for (auto &e: adj_list[a]) {
            if (visit[e] == 1)//<<<<< It's one, that means we found a cycle because it's still under consideration
                return true;
            if (visit[e] == 2)///<<<<<If the node is 2, that means we already backtracked from the node, so don't need to visit again
                continue;      
            ret = is_cycle(numCourses, adj_list, visit, e);
            if (ret)
                break;   
        }
        visit[a] = 2;////<<<<<When backtracking (done with the node), mark it as 2 (dead)
        return ret;
    }   


96. https://leetcode.com/problems/course-schedule-ii/

How would you implement this?

This problem looks an extension of previous problem. We can simple implement a DFS to do that. Now, when in DFS would you add the course?

When we reach at the end, we bracktack. And then we should add the course. Not when we visit a node. So, to find the actual result, we need to reverse it before returning.

Now, think about it. Will it work for this graph?

      ------------------
      |                |
      |                |
      |                v
a---->b------->c------>d         e
      |        |                ^ ^
      |        |                | |
      |        ------------------ |
      |                           |
      -----------------------------     
      
It will work if we start with node a. But, it will not work if we start with node b or c. So, here we cannot start from arbitrary node in DFS. We missed this point in course-schedule problem. There also we cannot start from arbitrary node. That may result wrong result because for instance, if we start with c, c and c, d, e will be visited. So, when we start from a, those nodes (c, d, e) will not be considered which may for cycle. So, in directed grapg in DFS, we need to start from a node with indegree 0. So, the code should look like:

class Solution {
    void dfs (int numCourses, vector<vector<int>> &adj_list,
              vector<int> &visit, int a, vector<int> &res, bool &iscycle) {
        visit[a] = 1;
        for (auto &e: adj_list[a]) {
            if (visit[e] == 1) {
                iscycle = true;
                return;
            }
            if (visit[e] == 2)
                continue;      
            dfs(numCourses, adj_list, visit, e, res, iscycle);
            if (iscycle)
                return;
        }
        visit[a] = 2;
        res.push_back(a);///<<<When backtracking, adding the node to result
    }
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> res;
        vector<vector<int>> adj_list(numCourses);
        vector<int> visit(numCourses);
        vector<int> indegress(numCourses);

        for (auto &e : prerequisites) {
            adj_list[e[1]].push_back(e[0]);
            indegress[e[0]]++;
        }

        for (int i = 0; i < numCourses; i++) {
            if (indegress[i] == 0 && visit[i] == 0) {////<<<<Only start from a node with indegree 0.
                bool iscycle = false;
                dfs(numCourses, adj_list, visit, i, res, iscycle);
                if (iscycle)
                    return vector<int>();
            }
        }
        
        if (res.size() != numCourses)////<<<<Explained below
            return vector<int>();

        reverse(res.begin(), res.end());
        return res;
    }
};


Note that, starting only from 0 indegree node has other consequnces. For instance, think about the graph.

   -->b------>C------>d
  /                   |
 /                    |
/                     v   
a<--------------------e


Here, there is no node with indegree 0. So, these nodes will not be visited at all. That's why, in the solution we check if we visited all the nodes

97. https://leetcode.com/problems/count-of-smaller-numbers-after-self/

How would you solve this?

Merge sort..How would you implement merge sort? What would be the base condition of merge sort?

I typically think that, when array size is 2, then we should stop and sort it. But, it can be better. Base condition can be array size = 1. That means, when only one element, then 
return. Merging logic will merge two arrays of size 1. ////<<<<<<<<

How would you implement merging? Would you use in-place merging or allocate extra place?

Let's think about in-place merging first. For instance, we need to merge this:

[1   5   8]   [2 6 7]

In in-place merging, it will work like:

[1  5  7]     [2  6  8] ----> add count of 8 to 3
[1  5  6]     [2  7  8] ----> add count of 7 to 2 /////<<<< But this is wrong. Here, 7 was in right array, then moved to left, and then move to right again. When it moves from left to right, we simply cannot add the count. That will be wrong. 

This is why, in-place merging will not work (to my knowledge) for this problem.

We need to create a temporary array and merge them. Now think again, how would you calculate the count in merging here (with temp array):

A[1  5  7]     B[2  6  8]

One solution can be: any time, a number moves from B to A's position, we can increment count of all the following elements of A. For instance, merging of A and B will look like:

A[1  5  7]     B[2  6  8]

Merging [1  2]  --> incremement count of 5 and 7 by 1. 

Merging [1  2 5  6] ---> increment count of 7 by 1.

This approach will work. But, we will need an inner loop to increment count of all the following elements of A. This will cause TLE. Can we do better?



Yes, simply count how many times a number is moving from B to A. Every time you are merging a number from A, add that count to that index like:

class Solution {
    void countSmaller(vector<int>& nums, vector<int>& indices,
                      int start, int end, vector<int> &res) {
        int to_insert;                  
        int mid = (start + end) >> 1;

        if (start == end)////<<<<<<Base condition is array size 1
            return;

        countSmaller (nums, indices, start, mid, res);
        countSmaller (nums, indices, mid + 1, end, res);

        vector<int> tmp(end - start + 1);/////<<<Create a temporary array. Don't try to create one array and reuse it for merging evertime. It's probably not too 
                                         //////expensive to create a temp array

        int num_moves = 0;
        for (int i = 0, j = start, k = mid + 1; i < end - start + 1; i++) {//////<<<<Note that here, index should run from start-to-end,  not 0-to-n
            if (j <= mid && k <= end) {
                if (nums[indices[j]] <= nums[indices[k]]) {
                    res[indices[j]] += num_moves;////<<<When you are merging a number from A, use the count
                    tmp[i] = indices[j++]; 
                } else {
                    num_moves++;///////<<<<< When a number moves from B to A, increment the count.
                    tmp[i] = indices[k++];
                }
            } else if (j <= mid) {
                res[indices[j]] += num_moves;////<<<When you are merging a number from A, use the count
                tmp[i] = indices[j++];
            } else {
                tmp[i] = indices[k++];
            }
        }
        move(tmp.begin(), tmp.end(), indices.begin() + start);////<<<< This is how you can do something like memcpy()
    }
public:
    vector<int> countSmaller(vector<int>& nums) {
        int n = nums.size();

        vector<int> res(n);
        vector<int> indices(n);///<<<Note that, we cannot modify the actual array. So, use this approach. I sometimes think of using hash for this, but don't do that.

        for (int i = 0; i < n; i++)///<<<<Use index to sort the array
            indices[i] = i;

        countSmaller(nums, indices, 0, n - 1, res);

        return res;
    }
};


98. What's wrong with the code?

if (nums[m] > (nums[k] * 2))


It should be:

if (nums[m] > ((long long)nums[k] * 2))////<<<<<This is very important to keep in mind


What's wrong with following code?

if (prefix_sum[j] - prefix_sum[i] >= lower)

It should be:

if ((long long)prefix_sum[j] - prefix_sum[i] >= lower)


Yes, simple addition and subtraction can also cause overflow.

What's wrong with following code?

int a = b + c;

It should be:

long long a = (long long)b + c;///<<<Note that, you need "long long" in both operation and destination



99. https://leetcode.com/problems/reverse-pairs/  

How would you implement this?     

Merge sort. How would you implement this during merging?


For instance, you have these two sorted arrays. How would you implement intended logic while merging?

A[2, 7, 9]   B[3, 4, 10]


I mistakenly think that, we need to implement the logic while merging logic. But, that's not necessarily true. You can implement the logic given you are given two sorted arrays. Then you can implement naive merging. ///////<<<<<<<<<<<<<<<<<<<<<<<<<<


Now, how would you implement the logic given you are given two sorted arrays?

The solution I came up was, I will iterate both array from right to left. The steps are shown below.
        i             j 
A[2, 7, 9]   B[3, 4, 10]    A[i] > 2 * B[j] is false
       
        i         j
A[2, 7, 9]   B[3, 4, 10]    A[i] > 2 * B[j] is true. count += 2

     i            j
A[2, 7, 9]   B[3, 4, 10]    A[i] > 2 * B[j] is false

     i         j
A[2, 7, 9]   B[3, 4, 10]    A[i] > 2 * B[j] is true. count += 1

.....


The code will look like:

    void reversePairs(vector<int>& nums, int start, int end, int &count) {
        int to_insert;                  
        int mid = (start + end) >> 1;

        if (start == end)
            return;

        reversePairs (nums, start, mid, count);
        reversePairs (nums, mid + 1, end, count);

        for (int i = end, j = mid; (i >= mid + 1) && (j >= start);) {////<<<<< Actual countining calculation based on the sorted arrays
            if (nums[j] > (long long)nums[i] * 2) {
                count += i - mid;
                j--;
            } else {
                i--;
            }
        }

        vector<int> tmp(end - start + 1);

        for (int i = 0, j = start, k = mid + 1; i < end - start + 1; i++) {////<<<<< Actaul merging
            if (j <= mid && k <= end) {
                if (nums[j] < nums[k]) {
                    tmp[i] = nums[j++]; 
                } else {
                    tmp[i] = nums[k++];
                }
            } else if (j <= mid) {
                tmp[i] = nums[j++];
            } else {
                tmp[i] = nums[k++];
            }
        }
        move(tmp.begin(), tmp.end(), nums.begin() + start);
    }

100. https://leetcode.com/problems/range-sum-query-2d-immutable/

How would you implement this?

I initialially thought storing prefix sum would work. But, will it?

We will need prefix sum, but it should contain different things. For instance, you are given following input. What would your prefix sum matrix look like? How would you calculate 
range sum from there?

--------------------------
|  2  |   3  |  -1 |  -2  |
...........................
|  4  |   3  |  -2 |  5   |
---------------------------
|  1  |   2  |  3  |  4   |
---------------------------
|  -2  |  3  |  2  |  2   |
---------------------------

Each point i, j will contain sum of all the elements of submatrix (0,0) and (i,j) as following

--------------------------
|  2  |   5  |   4 |  2  |
...........................
|  6  |   12 |   9 |  11 |
---------------------------
|  9  |   15 |     |     |
---------------------------
|  7  |     |     |      |
---------------------------


Then you can use geometric concept to calculate range sum. If you can't find the solution, look at my own solution.


Now, how would you calculate prefix sum of the matrix? Note that, it's easy to calculate prefix sum of all the elements from (0, 0) to (i,j). But, calculing prefix sum in submatrix can be tricky. But, we can calculate it like DP. First calculte the prefix sum of first column. Then  first row. Then based on left and up value, we can calculate the current value. For deatils, look at my own solution.


101. How to calculate prefix sum of an array?

I tend to do this as:

  int running_sum = 0;
  for (int i = 0; i < n; i++) {
    running_sum += nums[i];
    prefix_sum[i] = running_sum;
  }

But, can you do it better?

It can be better written as:

        prefix_sum[0] = sums[0];
        for (int i = 1; i < n; i++) {
            prefix_sum[i] = prefix_sum[i-1] + nums[i]; 
        }


102. https://leetcode.com/problems/count-of-range-sum/

How would you implememt this?

I remember from memory that it's a merge sort, but how would you implement merge sort in this problem?

Typical way to solve this problem is to create prefix sum array. Then, for each element, find the difference from other elements and check if the difference is in the range. This will require O(n^2). Can you do it better?

The trick is, when we do merge sort, we have two partitions sorted. If partition are sorted, we don't need to check all the combination. For instance, we have two partitions:

A[-2 0 3 5] B[-5 -1 0 4 5] Target range is [-4, 4]

How would you find the count of range sum?


I tend to find a O(n) solution, but that's not possible.

For each element of A, find the smallest element in B for B[j] - A[i] >= lower. Also find the largest element in B for which B[k] - A[i] <= upper.
Then, for A[i], the count += k - j + 1;

This however gets TLE. How can I improve this?

For instance, 

A[-2 0 3 5] B[-5 -1 0 4 5] Target range is [-4, 4]

In the first iteration, it looks like following:

A[-2 0 3 5] B[-5 -1 0 4 5] Target range is [-4, 4] Increment count += 3
   ^           ^    ^
               lo   hi
For next element of A, do we really need to start from the beginning of B and end of B?

No, for next element of A, we can start from the range we found in last iteration (lo, hi). This will avoid lots of checking. But, will it work?

Not really. We can start from lo, but we cannot start from hi. This is because next element of A is higher than previous element. So, element higher than hi can also produce right solution. So, keeping track of hi and lo will not work. 

How can we still solve it?

We can keep track of lo and then count incrementally how many elements fall into the range. So the code will look like:


          
Moral of the story: I tend to think that, when we need to count how many elements migrate from right partition to left partition, only then we use merge sort. But, that's not true.
We can use merge sort for any application. When we need to iterate an array and the array is not sorted and our algorithm can be improved with sorted array, it's possible to use merge sort and apply our operation on the partition rather than the whole array.  


103. How to use inline_merge()? 

Following example shows it.

class Solution {
    void countRangeSum (vector<long long> &prefix_sum, int start, int end, 
                        int lower, int upper, int &count) {
        int n = prefix_sum.size();
        int mid = (start + end) >> 1;

        if (start == end)
            return;
            
        inplace_merge(prefix_sum.begin() + start, prefix_sum.begin() + mid + 1,/////<<<Start of the second part
                      prefix_sum.begin() + end + 1);//<<<<<<<<<<<End of the second part + 1
    }


How to copy one vector into another?

 vector<int> v1 = {1, 3, 4, 5, 20, 30};
     
 vector<int> v2(6);
  
 // using copy to copy both vectors into
 // one container
 auto it = copy(v1.begin(), v1.end(), v2.begin());/////<<< Source.begin(), Source.end, Destination.begin()
 
 
How about move()?


This is same as copy (as follows):

move(tmp.begin(), tmp.end(), indices.begin() + start); /////<<< Source.begin(), Source.end, Destination.begin()


Note that, the destination vector has to be pre-allocated in both case.
 
 
What if destination is not pre-allocated? 

Then the copy code should look like:

copy(v1.begin(), v1.end(), back_inserter(v2));/////<<< Source.begin(), Source.end, Destination.begin()
 

104. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/

How would you implement it?

I tend to think of using sliding window algorithm. But, is it the right solution?

I tend to think that if I don't find a match, from where I would start looking in the 'pattern' string. But, is it the right solution?

Later I figured out that this is not a sliding-window algorithm at all. In brut-force approach, we check the whole pattern for the each character of the haystack string. But, this is not right. Anytime we find a un-match, we can skip check for all the character that doesn't match the first character of the 'pattern'. This solution is accepted in leetcode.


But, look carefully. This is same is native implememtation. In naive implementation, we also skip if it doesn't match the first character of the pattern. And naive solution is also accepted in leetcode.


Better solution in KMP algorithm. KMP algorithm is only good if the pattern string has lots of repeattative characters. If there is not much repeative characters, KMP will not provide any improvement. So, it may not make much sense.

For instance, if pattern and string is as following: 

AAAAAAAAbbbbbAAAAAAA -- pattern
      ^ 
      |
AAAAAABAbBBBBAAAAAA  --- input text


Here, we found an unmatch. In this case, naive approach would do as follows:

 AAAAAAAAbbbbbAAAAAAA -- pattern
 ^ 
 |
AAAAAABAbBBBBAAAAAA  --- input text


KMP will instead do as following:    

AAAAAAAAbbbbbAAAAAAA -- pattern
     ^ 
     |
AAAAAABAbBBBBAAAAAA  --- input text


Note that, KMP will be beneficial only of pattern has lots of substrings that can be prefix of the pattern. As this is such a unique characteristics, we don't implement KMP

105. https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/

How would you implement this?

I found this problem difficult. Sometimes, I found problem difficcult because I try to over-optimize it. If it seems difficult, find a naive version first, then try to optimize it. Don't try to optimize it from the get go.

Sometimes, it helps to avoid complexities if you know what can be done and what can't be done.

For instance, we already know that there is no good solution to find sub string in a string (KMP only help in certain case). So, we know that, we have no scope of optimizing of checking all the substrings.

So, we can try to optimize string generation from number. How can you generate bitstring of all the number from 1 to n?

We can do it it a loop. If right-most bit of a number is 0, in next number, right-most bit will be 1.

If right-most bit is 1, the we need to do as:

10001000111 to 10001001000

How can we do that?

You can manually count how many 1's do you have in a loop. Can you do better?

If      a = 10001000111
       a+1= 10001001000
-----------------------
a ^ (a+1) = 00000001111

From here, you simply can count show many 1's do you have. 

The code looks like:

    vector<string> getBinStr(int n) {
        vector<string> res;
        string s = "1";

        res.push_back(s);
        for (int i = 1; i < n; i++) {
            if ((i & 1) == 0) {
                s[s.length() - 1] = '1';
            } else {
                int num = ((i ^ (i + 1)) >> 1) + 1;
                int count = log10(num) / log10(2);
                if (s.length() == count) {
                    s.insert(0, "1");
                }
                s[s.length() - count - 1] = '1';
                for (int k = s.length() - count; k < s.length(); k++) {
                    s[k] = '0';
                }
            }
            res.push_back(s);
        }
        return res;
    }
    
Unfortunately it still gets TLE. Another solution can be as follows:

    vector<string> getBinStr(int n) {
        vector<string> res;
        queue<string> q;
        string cur;

        q.push("1");
        int i = 0;
        while (i < n) {
            cur = q.front();
            res.push_back(cur);
            i++;
            q.pop();
            q.push(cur + "0");
            q.push(cur + "1");
        }
        return res;
    }
    
The idea is taken from https://www.geeksforgeeks.org/interesting-method-generate-binary-numbers-1-n/. Unfortunately, it also gets TLE

Why it's getting TLE?

Here, we are generating following numbers from 11:

11
110
111
1100
1111
1110
1111

Do you really need these for substring check? If you only check the following, that would be sufficient:

1100
1111
1110
1111

So, we are unnecessarily comparing with many other numbers. Based on the observation, I modified the previous code. There I removed all the numbers whose lengths are smaller. 


    vector<string> getBinStr(int n) {
        vector<string> res;
        queue<string> q;
        string cur;

        q.push("1");
        int i = 0;
        while (i < n) {
            cur = q.front();
            res.push_back(cur);
            i++;
            q.pop();
            q.push(cur + "0");
            q.push(cur + "1");
        }

        int max_len = res.back().length();
        for (auto it = res.begin(); it != res.end();) {
            if (it->length() < max_len) {
                it = res.erase(it);
            } else {
                it++;
            }
        }
        return res;
    }
    
    
Unfortunately it still gets TLE.

Now, try another approach. Find how many digits it needs. And use backtracking to generate all possible string of that digit length. 

    void get_bitstr(int num_digits, string cur_str, vector<string> &res) {
       // cout << "cur_str = " << cur_str << endl;
        if (cur_str.length() == num_digits) {
            res.push_back(cur_str);
            return;
        }
        if (cur_str != "" && cur_str != "0")
            get_bitstr(num_digits, cur_str + "0", res);
        get_bitstr(num_digits, cur_str + "1", res);
    }

    string binary(int a) {
        string s;
        int res;

        while (a) {
            s += to_string(a % 2);
            a = a/2;
        }
        reverse(s.begin(), s.end());
        return s;
    }

    vector<string> getBinStr(int n) {
        vector<string> res;
        int num_bit_digits = (log10(n) / log10(2)) + 1;

        if ((n & (n+1))) {
            while (((log10(n) / log10(2)) + 1) == num_bit_digits) {
                res.push_back(binary(n));
                n--;
            }
        }
        if (n == 0)
            return res;    
        num_bit_digits = (log10(n) / log10(2)) + 1;
        string cur_str;
        get_bitstr (num_bit_digits, cur_str, res);
        return res;
    }    
    
    
Unfortunately this approach also get TLE.

Why it's still getting TLE??????

Note that, you are generating all possible strings first and then checking all of them. Do you really need that? 

Everytime you generate a string, you can immediately check if it's a substring. If not, you can immediately tell that it's not a substring. That fixes the TLE error.



105. https://leetcode.com/problems/clumsy-factorial/

How would you solve this?

can you solve this using recursion? 

It seems so, but, if you write it as an equation on paper, and represent the equation a a function of itself, you can see that it's not possible. So, you need different approach. If you can't figure out the solution, take a look at my own solution.    

106. https://leetcode.com/problems/binary-tree-maximum-path-sum/

How would you solve this? If you can't figure out, look at my own solution.

107. How to get the first element of a unordered_set?

Following doesn't work for unordered_set (it works for vector):

int a = us.front();

Right solution is:

int a = *us.begin();//////<<<<<Note that, you don't need to do *(us.begin())


108. https://leetcode.com/problems/minimum-height-trees/

How would you implememt this?

You can implememnt a nieve solution where you can the height for each node as root. This will cause TLE. What would be an efficient solution for this problem?

As leetcode solution suggested, there can be at most 2 such nodes. Those nodes are centroids (located center of the tree/graph). How can you find the nodes?

One initial intuition is to calculate degrees of each node. Nodes with highest degree would be our result nodes. But, this may give us wrong result. In order to find correct result, find all the nodes that are on  the periphery of the tree and cut them. Repeat this process until you have 1 or 2 nodes left. This idea is taken from leetcode. Take a look at my own solution if it's not clear. 

109. https://leetcode.com/problems/all-possible-full-binary-trees/

How would you implememnt this?

At first it may seem like backtarcking. But, can you really use backtracking?

No, because you need to create a separate tree of every combination? How would you solve this? 

If you can't figure it out, look at my own solution.

110. https://leetcode.com/problems/basic-calculator/

How would you implememt this?

For instance, you have this expression: 5 - 3 + 1

Which direction (left-to-right or right-to-left) would you evaluate it? Does it really matter if you only have + and -?

Yes, it matters. If you evaluate right to left, answer is 1. If you evaluate left to right, answer is 3. You  should evaluate from left to right.

Now, how would you implement this?

You can use stack. When you get ')', you need to evalaute everything you found so far from last '('. How can you do that?

Can you evealuate this using this stack? 

No, if you use this stack to evaluate it, you are evaluting it from right to left. But, you need to evaluate left to right.

To do so, you need to put everything till last '(' into another stack. That way, your expression is reversed. Now, if you evaluate it, it will be left to right.


Implementing -4 or -() also have some challenges. This is a quite tough problem. Look at the my own solution if needed.

111. https://leetcode.com/problems/basic-calculator-ii/

How would you implement this?

Note that this problem is easier than basic-calculator. 

It may seem that this is a recursion problem. But, if you notice carefully, recursion will not work (like clumsy factorial problem). This problem can be solve using stack (like clumsy factorial).

If we want to perform some part of the computation before other, stack can be very useful. For instance, here we want to compute '*' or '/' before +/- (like clumsy factorial). So, we can execute those using stack. Then we will only have +/-. Then we can solve those without worrying about * or /.

112. https://leetcode.com/problems/target-sum/

How would you implement this?

It's easy to think of this as backtracking problem as. For each element, try + and -. The code will look like:

class Solution {
    int calc_sum (vector<int>& nums, vector<char>& ops) {
        int n = nums.size();
        int sum = 0;

        for (int i = 0; i < n; i++) {
            sum += ops[i] == '+' ? nums[i] : -nums[i];
        }
        return sum;
    }
    void findTargetSumWays(vector<int>& nums, int target,
                        vector<char>& ops, int idx, int &count) {
        int n = nums.size();
        if (idx == n) {
            if (calc_sum (nums, ops) == target)
                count++;
            return;
        }
        ops[idx] = '+';
        findTargetSumWays (nums, target, ops, idx + 1, count);
        ops[idx] = '-';
        findTargetSumWays (nums, target, ops, idx + 1, count);
    }
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        vector<char> ops(nums.size());
        int count = 0;

        findTargetSumWays (nums, target, ops, 0, count);
        return count;
    }
};


But, it will get TLE. Can you do better?

Do you really need to check all the combination and check the combination that work? Problem  with this approach it will produce all possible combination most of which are not useful.

Can you only produce the combination  that are useful? 

Start with target. For instance, target = 3 and input array A = [1, 1, 1, 1, 1]

                        3
                      /   \
                    2      4 
                   / \    / \
                 1    3  3   5
                 
Here, we are using bottom up approach. From the target, we are backtracking towards the root. Note that, such bottom-up approch are often more efficient than top-down approach. This bottom-up approach is similar idea as DP, though we are not using DP. We can use backtracking to implement the bottom-up approach. The solution would look like:

class Solution {
    void findTargetSumWays(vector<int>& nums, int target, int idx, int &count) {
        int n = nums.size();
        if (idx == n) {
            if (target == 0)
                count++;
            return;
        }

        findTargetSumWays (nums, target + nums[idx], idx + 1, count);
        findTargetSumWays (nums, target - nums[idx], idx + 1, count);
    }
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int count = 0;

        findTargetSumWays (nums, target, 0, count);
        return count;
    }
};

113. https://leetcode.com/problems/3sum-smaller/

How would you implement this?

Note that, I faced this problem in count-of-range-sum as sub problem. There I was getting TLE. But, my current solution works fine here. If you can't figure out the solution, take a look at my own solution.

114. https://leetcode.com/problems/minimum-path-sum/

How would you implement this?

My immediate hunch is to use BFS to implement the shorteest path problem. Such solution worked for snake-ladder problem.

Can we optimize it? 

Note that, if we can reach (1,1) from (0, 1) and (1, 0). Do we really need to consider both path? Only one path would be the minimal. But, in BFS, either we need to consider (1,1) both times, which works but, it will get TLE. 

If we (1,1) already marked as a smaller value, we may skipping adding to BFS again. This also casues TLE. Can there be a better solution?


Yes, you can easiy implement bottom-up DP like approach to solve this problem. If you can't  figure out the solution, take a look at my own solution. You will see the correct solution and the solution that gets TLE.

115. https://leetcode.com/problems/spiral-matrix/

How would you implement this? If you can't figure out, take a look at my own solution.

116. https://leetcode.com/problems/spiral-matrix-iii/

How would you implement this?

I found a pattern. It moves following number of moves in one direction:

1, 1, 2, 2, 3, 3,...

Based on this observaton, I implemented my solution. If you can't figure out, look at my own solution.

117. https://leetcode.com/problems/pacific-atlantic-water-flow/

How would you implement this?

If you can't figure out the solution, look at my own solution.

Note that, here, during DFS, I didn't use visit array. In the past, we used visit array, we set visit of a node to 1 when visit for the first time. When we done with node, we set the visit = 2. But, we didn't do it here. Will that affect here?

Here, we simply need to mark the nodes, from where water can come to see. Here, we don't don't need to worry about coming back to node using another path. So, we don't need visit.

118. https://leetcode.com/problems/longest-increasing-path-in-a-matrix/

How would you implemement this?

Clearly we can do DFS. Can we optimize it?

Note that, typical DFS will visit same node multiple times. But, do you really need that. When you visit a node in DFS, you calculate the longest path from that node. So, we should store the result. Subsequently, if you come across the node, you can reuse the result.

Also note that, here, we can come to a previsited node from a different path and we don't want to visit it again. So, we should use visit = 1 to make mark as active (on the path). When the node is finised visiting, mark it as 2 (dead). It also means that longest path from the node is calculated. 

119. https://leetcode.com/problems/shortest-path-in-binary-matrix/

How would you implemement this?

This is BFS. From the question, I wasn't clear what the adjacent nodes would be. It shoud be all the 8 adjacent nodes.

How would you implement visit here?

I tend to use a hashset to implement visit. Even though it's possible, better solution is to use visit array.

If you can't figure out the solution, look at my own solution.

120. https://leetcode.com/problems/subarray-sum-equals-k


How would you implememt this?

You can naive approach, but it will take O(n^2). You can use prefixSum, but it will also take O(n^2). Can you make it better?

Note that, this problem is very similar to count-of-range-sum. We can use the same merge-sort to implement this. The cost is O(nlogn). But, it still gets TLE. Can you do better?
Say, O(n)?

For every element of A[i], check if (A[i] - target) exists in the hash map. If yes, increment the count, otherwise simply add it to hashmap. The solution is taken from #4 at:

https://leetcode.com/problems/subarray-sum-equals-k/solution/ 

For implementation, you can take a look at my own as well. This is a very interesting problem!!!!!!!!!!


121. https://leetcode.com/problems/find-smallest-common-element-in-all-rows/

How would you implement this?

This is same as merging merge-k-sorted-lists. 

Look at my own solution if you cannot figure it out.

122. How can you know that unordered_map<int, int> has just one key-value pair?

Yes, you can use hash.size().

122. https://leetcode.com/problems/single-element-in-a-sorted-array/

How would you implemement this?

If you can't figure out the solution, take a look at the solution.

123. https://leetcode.com/problems/word-ladder/

How would you implement this? If you can't figure out the solution, look at my own solution.

124. If you need to delete elements from a list, which data structure would you use?

Note that, delete is: search + earse. 

So, vector will cost O(n) + O(n)
    list will cost  O(n) + O(1)
    hash will cost O(1) + O(1)
    tree will cost O(long) + O(1)
    
So, you should use hash or tree. What would be the code?

auto it = hash.find (key);
if (it != hash.end())
  hash.erase (it->first);
  
Can you do the following?

unordered_set<string> copiedList
copiedList.erase(copiedList.find(beginWord));////<<<<<<<<Wrong


No, it will cause issue if find() returns end iterator. It should be:

      if (copiedList.find(beginWord) != copiedList.end())
            copiedList.erase(copiedList.find(beginWord));
            
Follow this convention. Don't use 'auto it'.            

Can you do the same for vector? like as follows?

      vector<string> wordList;
      if (wordList.find(beginWord) == wordList.end())
         wordList.push_back(beginWord);
  
No, vector doesn't have the find()!!!!!!!!!!///<<<<<<<<< Above code will not work

But, you can do this!!!!

        if (find (wordList.begin(), wordList.end(), beginWord) != wordList.end())
            wordList.push_back(beginWord);  
  
  
125. How can you initialize a set with vector?


unordered_set<int> us (v.begin(), v.end());/////<<<<<<<


126. We know what std::move() does? But, is it more effecient that deep copy?

Yes, std::move() does shallow copy. So, it's more efficient.   
  
127. Where do you check if you have reached the end of BFS? You can do it at the beginning of while loop after popping the item from queue. You can also do it in the for loop when expanding. Which one is better? For instance, you can do it in following positions:

q.insert(start);                                
visit[start] = true;
while (!q.empty()) {
  int cur = q.front();
  q.pop();
  ///<<<<<<<<You can check if you have reach the end
  for (auto e : adj[cur]) {
      ///<<<<<<<<You can check if you have reach the end
    if (!visit[e]) {
      q.push(e);
      visit[e] = true;
    }
  }
}

Which one would be better?

You should do it in the for loop (the second one). When  you reach the node, you should immediately say that you reached the end. The first place (after popping the item from queue) is inefficient. You are adding the nodes to the queue. The the node will be popped from the queue. So, you are adding one extra level of items to the queue which is not very efficient. In case of large tree, one extra level can add a lot of extra nodes. 
  
128. https://leetcode.com/problems/word-ladder-ii/

Very interstsing problem!!!

How would you implement this?

This is BFS, right? Now, how would you find all possible paths? In word-ladder, whenever we found the shortest path, we immediately stop. But, we cannot do that here. 

One approach can be keep track if we have found the shortest path. If we found the shortest path, and we are visiting path longer than the path, we can immediately stop.

Now, how to keep track of the path?

In addition to keeping track of the current node, we also should keep the path in queue like:


hit

hit hot 
hit hot  dot
hit hot  lot
hit hot  dot dog
hit hot  lot log

Note that, this approach requires a lot of copying!!!!!!

Now, can you use traditional BFS?

Think about the following tree:

                               red
                             /     \
                          ted       rex
                        /    \         \
                 >>>>tex     tad        tex<<<<<
                    /         /         /
                  tax        tax       tax
                  
                  
Here, in level 3, we have tex twice. In typical BFS, when we visit tex for the first time, we mark it as visited. We will not visit the second tex. But in this case, we need to visit both. How to do that? Also note that, if tex appears after level 3, we don't want visit it that time.

So, we want to visit a node after the node is expanded.


So, in typical BFS, do we do the following:

q.insert(start);                                
visit[start] = true;///<<<<<<<<<<<<<<<<<<<
while (!q.empty()) {
  int cur = q.front();
  q.pop();
  
  for (auto e : adj[cur]) {
    if (!visit[e]) {
      q.push(e);
      visit[e] = true;///<<<<<<<<<<<<<<<<<<<
    }
  }
}

But, here, my gut says do the following. Will it work?

q.insert(start);                                
while (!q.empty()) {
  int cur = q.front();
  q.pop();
  visit[cur] = true;///////<<<<<<Only visit it when expanding.
  for (auto e : adj[cur]) {
    if (!visit[e]) {
      q.push(e);
    }
  }
}

Here, both 'tex' in level 3 will be added to queue. Then 'tex' will be set visited twice, nothing wrong with that.

But, it will still not work!!!!!!!!!!!!!!!!!/////<<<<<<<<<<<<<<<<<<<<<<<<<<


Yes, we will need to typical BFS. Here, I will explain why. Think about the tree:

           hot
         /     \
      dot       lot<<<<<<
    /     \       |
 dog    lot<<<    log
 
Our previous code will mistakenly add dot--lot even though it shouldn't be added because there is a lot in the previous level. So, stick to generic BFS.

Now, how would you solve the problem where you need to add same node multiple times if they appear twice in a level?

Simple!! Store the level in visit. If you are visit a node twice and they are in the same level, allow it.


I implemented that. But, it gets TLE. Why is that?//////<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

One reason can be we are copying all possible paths which is expensive. Another more important reason is one directional BFS will create so many path that will not lead to endWord. For instance, in the previous figure, we only showed the nodes that will lead to endWord. But, following figure shows all the nodes BFS will explore:///<<<<<<<<<<<<<<<<<<


                               red
                             /     \
                          ted       rex
                        /    \      /   \
                     tex     tad   rox   tex
                    /  \      /    |     /
                  tax  ten  tax   box tax
                  
                  
Note that, in naive BFS, the problem space will be too huge, but it doesn't need to be.

How can we improve that?

Bi-directional search.////<<<<<<<<<

Can we use Bi-directional search here?

No, there, we are not just finding any path. We need to find shortest path. How can we achive that?


BFS + Backtracking////<<<<<<<<<

Backtracking is simply start searching from the opposite direction. We can use BFS or DFS when searching in opposite direction (DFS makes more sense here). 

So, the idea is we use BFS to find the shortest path. Along the way, we create a graph that we will travarse in the opposite direction.

Once we reach the endWord, we can do DFS from endWord towards startWord. Note that, in this approch, all the unnecessary path in the previous picture that doesn't lead to endWord will not be considered!!!!!!!

This is why, it will not result in TLE. This approach is taken from leetcode approach 1.

I implemented this approach as follows. This is quite a hard pronblem.


class Solution {
    bool is_adjacent (string &s1, string &s2) {
        int n = s1.length();
        int count = 0;

        if (s1 == s2)
            return false;

        for (int i = 0; i < n; i++) {
            if (s1[i] != s2[i]) {
                count++;
                if (count > 1)
                    return false;
            }
        }
        return true;
    }

    void add_edges (string dest, vector<string>& wordList,
                    unordered_set<string> &visit,
                    unordered_map<string, vector<string>> &adj_list) {
        for (auto &e : wordList) {
            if (e != dest && visit.count(e) == 0 && is_adjacent(e, dest))
                adj_list[e].push_back(dest);
        }
    }

    void dfs (string cur, unordered_map<string, vector<string>> &adj_list,
              vector<string> &path, vector<vector<string>> &res, string &end) {//////<<<<<DFS implementatoion can be very simply if it's directed graph!!!!!
                                                                               //////<<<<You don't need to keep track of two visit value
        path.push_back(cur);
        if (cur == end) {
            vector<string> cur_path = path;
            reverse(cur_path.begin(), cur_path.end());
            res.push_back(cur_path);
            path.pop_back();
            return;
        }
        for (auto &e : adj_list[cur]) {
            dfs (e, adj_list, path, res, end);
        }
        path.pop_back();
    }
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        unordered_map<string, vector<string>> adj_list;//////<<<<You can also implement adjacency list as hash when your keys are string, not int (0-n)
        queue<pair<string, int>> q;
        unordered_map<string, int> visit;//////<<<<<<<Note that you can implement visit array as a set, if you don't know how many nodes you have
                                         //////<<<<As we need to store the level of the found node, we use hash
        string cur_str;
        int cur_lev;

        q.push(make_pair(beginWord, 1));
        visit[cur_str] = 1;
        while (!q.empty()) {
            cur_str = q.front().first;
            cur_lev = q.front().second;
            q.pop();
            for (auto &e : wordList) {
                if (visit.find(e) != visit.end() && cur_lev + 1 == visit[e] && is_adjacent(e, cur_str)) {////<<<<If we visited the node in the same level, we still need to 
                                                                                                         ////<<<<<consider the node
                    adj_list[e].push_back(cur_str);
                    continue;
                }
                if (visit.find(e) != visit.end() || !is_adjacent(e, cur_str))
                    continue;
                adj_list[e].push_back(cur_str);
                visit[e] = cur_lev + 1;
                q.push(make_pair(e, cur_lev + 1));
                if (e == endWord) {////<<<<When foudnd the end word, jump . The code would be cleaner
                    goto backtrack;
                }
            }
        }

backtrack:

        while (!q.empty()) {
            if (q.front().second > cur_lev)
                break;
            cur_str = q.front().first;
            q.pop();
            if (is_adjacent(endWord, cur_str)) {
                adj_list[endWord].push_back(cur_str);
                visit[cur_str] = cur_lev + 1;
            }
        }
        
        vector<vector<string>> res;
        vector<string> path;

        dfs (endWord, adj_list, path, res, beginWord);
        return res;
    }
};



129. https://leetcode.com/problems/encode-and-decode-strings/

How would you implement this?

You need to find a delemeter that will not be present in the string. Thankfully, we can use any non-aschii character to do that. Note that, ASCII characters are 0-256. So, any character greater than 256 can be used.

class Codec {
public:

    // Encodes a list of strings to a single string.
    string encode(vector<string>& strs) {
        string res = strs[0];


        for (int i = 1; i < strs.size(); i++) {
            res += 257;//////<<<<<<<Note that, we can simply add a non-aschii character as this.
            res += strs[i];
        }
        return res;
    }

    // Decodes a single string to a list of strings.
    vector<string> decode(string s) {
        vector<string> res;
        int start = 0;
        int end;

        do {
            end = s.find(257, start);///////<<<<<See how we using find to find the delemeter, inteas of loop. Also note that first param is the string that we are looking, second
                                     /////<<<<<param is the index where we start from
            if (end == string::npos)
                res.push_back(s.substr(start));
            else
                res.push_back(s.substr(start, end - start));
            start = end + 1;    
        } while (end != string::npos);///<<<<<<
        return res;
    }
};

How can you implememt it such that it works for any kinds of character? String itself can have unicode characters.

Instead of using a character as a delemeter, use a fixed length string what will tell the size of the next chunk (leetcode approach 2).

If you can't figure this out, take a look at my own implementation.

130. https://leetcode.com/problems/add-two-numbers-ii/

How would you implement this? If you can't figure it out, look at my own solution.

131. https://leetcode.com/problems/sum-of-two-integers/

How would you implememt this?

I typically use binary addition algorithm. But, will it work?


For instance, if a = 15, b = -20, will it work?

No, binary addition will treat -20 as a positive #. So, it will not work.

How to solve this?

If one number is positive and another is negative, you need implement binary subtraction algorithm as well.

Now, can the binary subtraction alkgorithm handle situtation like a = 5 , b = -8?

No, the result is negative. So, the algorithm will keep having borrow as 1. So, you need to handle the case manually and stop when  you reach position 64. If you try to shift more than 64, the program will crash.


The code will look like:

class Solution {
    int add (int a, int b) {
        long long sum = 0, carry = 0;
        long long lsb1, lsb2, bit_pos = 0, res;

        while (a || b || carry) {
            lsb1 = a & 1;
            lsb2 = b & 1;
            a = a >> 1;
            b = b >> 1;
            res = lsb1 ^ lsb2 ^ carry;
            carry = (lsb1 & lsb2) || (lsb1 & carry) || (lsb2 & carry) ? 1 : 0;
            sum = sum | (res << bit_pos);
            bit_pos++;
        }
        return sum;        
    }
    int sub (int a, int b) {
        long long sub = 0, borrow = 0;
        long long lsb1, lsb2, bit_pos = 0, res;

        while (a || b || borrow) {
            lsb1 = a & 1;
            lsb2 = b & 1;
            a = a >> 1;
            b = b >> 1;
            int tmp = lsb2;
            lsb2 = lsb2 ^ borrow;
            borrow = tmp & borrow;
            res = lsb1 ^ lsb2;
            if (!borrow && !lsb1 && lsb2)
                borrow = 1;
            if (!a && !b && bit_pos == 64)/////<<<<<In subtraction, if you reach 64-th bit position, stop 
                break;    
            sub = sub | (res << bit_pos);
            bit_pos++;
        }
        return sub;        
    }
public:
    int getSum(int a, int b) {
        if (a >= 0 && b >= 0)
            return add (a, b);///<<<If both numbers are postive, use add
        else if (a < 0 && b < 0)
            return  -add(abs(a), abs (b));///<<<If both numbers are negative, use add
        else if (b < 0)
            return sub (a, abs(b));///<<<<Otherwise, use subtract
        else
            return sub (b, abs(a));///<<<<Otherwise, use subtract
    }
};



If you can't figure out the solution, take a look at my own implementation.

132. https://leetcode.com/problems/perfect-squares/

How would implement this?

If you can't figure out, look at my own solutions.

Note that, many problems initially look like backtracking. Then when you try to solve it as a bottom-up approach, you see that it's possible. The problem suddenly becomes a DP.

DP is also much smaller and easier to implement (I know, I will have hard time to comprehend in the future day when  I see this line :) ) 

133. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/

How would you implememt this?

Take a look at best-time-to-buy-and-sell-stock and best-time-to-buy-and-sell-stock-ii

There, we basically find all the upword slopes.


       /\
  /\  /  \
 /  \/    \  /
/          \/

Now, how would you implemenet best-time-to-buy-and-sell-stock-iii?

I sometimes try to store all the upward slopes and add the largest 2 upward slopes. But, that will not work. Why is that?

        C
  B    /\
  /\  /  \   D
 /  \/    \  /
/          \/
A

This is because in this problem, A can be matched wuth B, C and D. Which one will you consider? You need to consider all the options.

From this realization, the problem seems a lot like backtracking where we need to explore all the options. But, from our experuience, we know that many backtracking problem can be solved in bottom up fashion in DP.

Here, I figured out a solution by myself. We can partition the array into two parts and in each part we need to consider the largest slope. Now, we need to consider all the partion points. If you can't figure out the solution, look at my own solution.

BTW, this leetcode also uses the same approch and calls in bidirectional DP.

134. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/

How would you implement this?

Very intersting problem. Note that, this problem has lots of similarities with Design Space Exploration. 

From the problem, I have a gut feeling that this will be DP. But, how would you formulate DP here?

Note that, the different between the best-time-to-buy-and-sell-stock-iii and best-time-to-buy-and-sell-stock-iv is that we need to find k number of transaction instead of 2. Can we extend the idea of best-time-to-buy-and-sell-stock-iii to this problem?


Unfortunately no.

I couldn't find the solution for myself. Sometimes, simulating how top-down will work and extrapolate bottom up solution is not easy like in this problem. In such case, try to formulate it directly without thinking about bottom-up or top-down.

I found the solution  hint at https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2555708/easy-solution-explained-beginner-friendly-best-method/

Leetcode solution seem complicated. This is the excerpt of the solution.

dp[i][j] means max profit at day j with at most i transactions.

so there are two possible situations on day j:

do nothing on day j, which means at most i transactions are all done before day j, so dp[i][j] = dp[i][j-1]

sell at price[j], which means before day j there will be at most i-1 transactions.

and because you sell the stock on day j, you must have already bought it before day j.the last time you bought it before day j could be any day between [0, j-1].

let's say the last time you bought it on day jj, where jj is in range [0, j-1].


My implementation is as follows.

class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp (k, vector<int>(n));////<<<<Initialize a 2D vector

        int min_found = prices[0];
        for (int i = 1; i < n; i++) {
            dp[0][i] = max (dp[0][i-1], prices[i] - min_found);
            min_found = min (min_found, prices[i]);
        }

        for (int i = 1; i < k; i++) {///<<<We are calculating result of k based on k - 1 results
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j];
                dp[i][j] = max (dp[i][j], dp[i][j-1]);
                if (prices[j] < prices[j-1])////<<<<If current value is smaller than yesterday's value, no reason check further.
                    continue;
                for (int m = 1; m < j; m++) {
                    dp[i][j] = max (dp[i][j], dp[i-1][m] + 
                                    prices[j] - prices[m]);
                }
            }
        }
        return dp[k-1][n-1];
    }
};


Note that, if you are asked to caluclate something using k attemps, try if you can do for 1, 2, 3...k-1, k..

135. https://leetcode.com/problems/trapping-rain-water/

How would you implement this?

In the past, I found this problem very hard to implement. That's mainly because I tend to think in terms of all the points. 

What is the general idea here?

               |
|              |          |
|              |          |     |
|         |    |          |     |
|    |    |    |     |    |     |
----------------------------------
start


Start with the first point. When we find another point greater or same as the 'start' point, we found the end. Now we simply can calculate the amount of water trapped in start and end.

But, this will not work for the following:

|
|          |
|          |     |
|          |     |
|          |     |
----------------------------------


To solve this, we can simply reverse the vector and apply previous logic.

The who code should look like:

class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0;
        int n = height.size();
        int start = 0;

        for (int i = 1; i < n; i++) {
            if (height[i] >= height[start]) {////<<<<<<We found the end for the start
                for (int j = start + 1; j < i; j++) {
                    res +=  height[start] - height[j];
                }
                start = i;
            }
        }

        if (start != n - 1) {
            vector<int> rest (height.begin() + start, height.end());////<<<<<Consider the rest of the input that wasn't handled in the first pass
            reverse (rest.begin(), rest.end());
            res += trap (rest);
        }

        return res;
    }
};


136. How to find the maximum value from a vector?

vector<int> dp;

return *max_element(dp.begin(), dp.end())///<<<See we can do it one line!!!!!!!!


137. How to initialize the 2D vector ?

vector<vector<int>> dp(k + 1, vector<int>(prices.size()));///<<<See we can do it one line!!!!!!!!


138. https://leetcode.com/problems/interval-list-intersections/

How would you implemement this?

If you can't figure out my solution, take a look at my own solution.


139. https://leetcode.com/problems/merge-intervals/

How would you implemement this?

If you can't figure out the solution, take a look my own solution.


I found this problem extreamly hard when I looked at it in the beginning!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!/////////<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

This is beacuse I didn't consider sorting the list at all. I was trying iterate over the list and figure out a solution which is extreamly hard!!!!!!!!

KEEP IN MIND, INTERVALS PROBLEM MAY LOOK EXTREAMELY HARD IF YOU DON'T SORT THEM. SO, CONSIDER SORTING THEM. THEN DO WHATEVER YOU WANT TO DO.////////<<<<<<<<<<<<


140. https://leetcode.com/problems/interval-list-intersections/
     https://leetcode.com/problems/merge-intervals/
     https://leetcode.com/problems/meeting-rooms-ii/
     
Can you use projection approach that I learned from geeksforgeeks?

No, it will be too un-efficient. Project approach is only good if interval is small. But, here 0 <= starti < endi <= 10^6. So, projection will not be a good idea

141. https://leetcode.com/problems/meeting-rooms-ii/

How would you implement this?

I tend to use following approach


    --------------  -----------
          ------------------  ----
---------------------------------

Sort all the intervals by 'start'.
cur_start = intervals[0][0];
cur_end = intervals[0][1];

for (int i = 1; i < n; i++) {
  check if i-th interval overlaps with [cur_start, cur_end]; if yes, increment the count
}


This however will not work, because it will result 5 in the picture. However, the result should be 3.

How to solve it properly?

I later figured out a solution. If you can't figure out the solution yourself, take a look at my own solution.


I found this problem extreamly hard at the beginning, but later was able to solve it easily.

MORAL: IF SOMETHING LOOKS HARD, TRY NAIVE BRUTFORCE WAY TO SOLVE IT. BRUTFORCE WAY WORKED HERE!!!!!!!!!!////<<<<<<<<<<<


142. https://leetcode.com/problems/non-overlapping-intervals/

How would you implememt this?

If you can't figure out yourself, take a look at my own solution.


NOTE THAT, I FOUND INTERVAL PROBLEMS REALLY HARD AT THE BEGINNING. HOWEVER, THEY SEEM EASY. USUALLY THERE IS A PATTER LIKE SORT THE INTERVALS BASED ON START OR END. THEN FOR EACH INTERVAL i, DO SOMETHINHG WITH INTERVAL 0 TO i-1. THIS RESULTS IN O(N^2) SOLUTION WHICH IS FINE!!!!!!!!///<<<<<<<<


ALSO, MUST DRAW THE INTERVAL PROBLEM ON PAPER!!!!!!!!!!!!!!!!!!!!!!!!!!!///<<<<<<<<

143. 

https://www.geeksforgeeks.org/find-maximum-meetings-in-one-room/
https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/

How would you solve this?

If you can't figure out, take a look at my solution or text.

144. https://leetcode.com/problems/maximum-profit-in-job-scheduling/

How would you implememt this?

If you can't figure out the solution, take a look at my own solution.

There is a caveat in the implementation. Here, I store the indices in  an indices array and sort the array based on the endTime. The code looks as follows:

class Solution {
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        int n = startTime.size();
        vector<int> indices(n);
        vector<int> dp(n);

        for (int i = 0; i < n; i++) {
            indices[i] = i;
        }

        sort (indices.begin(), indices.end(), [&](int a, int b) {
            if (endTime[a] != endTime[b])////<<<<I often forget to mention what to do if they are the same
                return endTime[a] < endTime[b];////<<<<
            return profit[a] > profit[b];/////<<<<
        });
       ////......
       
       /* Another mistake I made was I wrote the code as://////<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        sort (indices.begin(), indices.end(), [&](int a, int b) {
            if (endTime[indices[a]] != endTime[indices[b]])///<<<<<<<<This is not right. We are already getting element of 'indices', so no need to do that
                return endTime[indices[a]] < endTime[indices[b]];
            return profit[indices[a]] > profit[indices[b]];
        });       
       */
    }
};

145. https://leetcode.com/problems/employee-free-time/

How would you implement this?

If you can't figure out, look at my own solution.


146. Look at these problems:

https://leetcode.com/problems/interval-list-intersections/
https://leetcode.com/problems/merge-intervals/
https://leetcode.com/problems/meeting-rooms-ii/
https://leetcode.com/problems/non-overlapping-intervals/
https://www.geeksforgeeks.org/find-maximum-meetings-in-one-room/
https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/
https://leetcode.com/problems/maximum-profit-in-job-scheduling/
https://leetcode.com/problems/employee-free-time/


All these problem looked very hard at the beginning. But, when we draw the proble on the paper and sort the intervals based on start or end, the problem becomes very simple. Then often need O(n^2) or O(n) runtime.

Why is that?

This is because, they all follow greedy algorithm. Greedy approch works surprisingly well here!!!!!!!!///////<<<<<<<<<<<<<<

147. https://leetcode.com/problems/course-schedule-iii/

How would you implement this?

If you can't figure out the solution, take a look at my own solution.
 
Note that, I used greedy approch here as well, but naive greedy approch directly doesn't work for few cases. In those cases, I had to modify my current greedy solution. This is also kind of greedy approch. But, when we come across an element, we are just checking if we could improve our greedy solution by replcing a previous element with this element.

148. https://leetcode.com/problems/meeting-rooms-iii/ 

How would you implement this?

If you can't figure out the solution, take a look at my own solution.

149. https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/

How would you implement this?

AT THE BEGINNING, I FOUND THIS PROBLEM EXTREMELY HARD, HOWEVER, WHEN I WROTE FOLLOWING DIAGRAMS AND NUMBERS, IT BECAME EASY!!!!!!!!!!/////<<<<<<<<



[5, 15, 25, 35, 45, 55, 65, 75, 85, 95]

after rotation:

[65, 75, 85, 95, 5, 15, 25, 35, 45, 55]

So, diagram after rotation:

     /
    /
   /left part
  /
 /
/


              /
             /
            /right part
           /
          /
 
 
What would be the algorithm?

class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size();

        if (n == 1)
            return nums[0];

        if (nums[0] < nums[n-1])/////<<<<The list is not rotated at all
            return nums[0];

        int mid, start = 0, end = n - 1;
        while (start <= end) {
            mid = (start + end) >> 1;
            if (nums[mid] > nums[0]) {///<<<<It's on the left part
                if (nums[mid + 1] < nums[mid])///<<<Check if can deduce the min
                    return nums[mid + 1];
                start = mid + 1;
            } else {//////////////////////<<<<<<<it's on the right part
                if (mid == 0) {//////<<<<<Note that, if start = 0, end = 1, mid will be 0. That will crash in the following if. To solve this, handle it manually. 
                               //////<<<<<I didn't need to handle such way in the past.
                    return nums[1];
                }
                if (nums[mid - 1] > nums[mid])///<<<Check if can deduce the min
                    return nums[mid];
                end = mid - 1;
            }
        }
        return 0;
    }
};

150. https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/submissions/

How would you implememt this? 

I followed the leetcode solution. Difference from original binary search is:

1. If you cannot say with part you are (left or right), just do start++ or end--. Step ahead slowly.
2. In general binary search, we compare with nums[0] or nums[n-1]. Here, compare with nums[start] or numsp[end].

If these stratements are not clear, take a look at my implementation. 

151. https://leetcode.com/problems/palindrome-partitioning/

How would you solve this?

if you can't figure out, take a look at my own solution.

NOTE THAT, HUGE NUMBER OF BACKTRACKING PROBLEM CAN BE SOLVED USING DP. AND THEY SHOULD BE SOLVED USING DP!!!!!!!.///////<<<<<<<<<<<< 


152. When to use move()?

For instance, you created a copy of another vector. You update the copy. Now you will assign the updated copy to another opbject. This will create another copy which is not necessary.
You should use move in this case. For instance, this is the solution of https://leetcode.com/problems/palindrome-partitioning/.

    vector<vector<string>> partition(string s) {
        int n = s.length();
        deque<vector<vector<string>>> dp(n);

        dp[n-1].push_back({{s[n-1]}});
        for (int i = n - 2; i >= 0; i--) {
            vector<vector<string>> prev = dp[i+1];
            for (auto &e : prev) {
                string tmp = "";
                tmp += s[i];
                e.push_back(tmp);
            }
            string substr = s.substr(i);
            if (is_palindrome(substr)) {
                prev.push_back({substr});
            }
            for (int j = i + 1; j < n - 1; j++) {
                string substr = s.substr(i, j - i + 1);
                if (is_palindrome(substr)) {
                    vector<vector<string>> tmp = dp[j+1];/////<<<<<<Create a temp based on another vector
                    for (auto &e : tmp)////<<<<<<<<<<Update the temp
                        e.push_back(substr);
                    move (tmp.begin(), tmp.end(), back_inserter(prev));/////<<<Adding the temp to another vector. Here, we should use move() instead of copy(). 
                }
            }
            dp[i] = move(prev);/////<<<<For the same reason here we should use move()
        }
        for (auto &e : dp[0] ) {
            reverse (e.begin(), e.end());
        }
        return dp[0];
    }
    
153. https://leetcode.com/problems/partition-labels/

How would you solve this?

if you can't figure out, take a look at my own solution.

154. https://leetcode.com/problems/longest-substring-without-repeating-characters/

How would you solve this?

if you can't figure out, take a look at my own solution.


Take a look how I am implememting sliding window algorithm:

class Solution {
public:
    
    int lengthOfLongestSubstring(string s) {
        int n = s.length();
        unordered_set<char> set;

        int res = 0;
        for (int end = 0, start = 0; end < n; end++) {///<<<<<<<We always increment end from 0 to n. That is, in each iteration, forward the sliding window by 1 item
            if (set.count(s[end]) == 0) {
                set.insert(s[end]);
            } else {
                while (start < end) {///////<<<<<<<<Inside loop, we move the start as needed
                    if (s[start] == s[end]) {
                        start++;
                        break;
                    }
                    set.erase(s[start++]);
                }
            }
            res = max<long> (res, set.size());/////<<<Note that max may need template if the two argumements don't have the same type
        }
        return res;
    }
};

155. Sometimes you may get compile error using min/max when the two data type of the arguments don't match. Use following approach in that case:

 res = max<long> (res, set.size());
 
156. These are the topic I found dificult:

a. Intervals (but later found easy after sorting based on start/end and iterate to get O(n^2) solution) 
b. Grpah problems. Some graph probles are really hard. Some DFS, BFS, bidirectional search etc can be hard too
c. I found sliding window the hardest so far. They may look like backtracking or DP, but they are not!!!!!!

DP is not really hard most of the time.

157. As I found sliding window so tough, i retracked and decided to solve other problems.


https://leetcode.com/problems/the-kth-factor-of-n/

How would you solve this?

if you can't figure out, take a look at my own solution.


158. https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/

How would you solve this?

At first I usually do brutforce approach which is O(n^2). IU will get TLE. How to fix that?


The problem seem a lot like merge sort problem. But, I couldn't solve it using merge sort. ///////<<<<<<<<

Can I solve it by sorting the number? 

Doesn't really. Sorting the number doesn't help.///////<<<<<<<<<<

A very intersting approach is to you can reduce all the numbers between 0-60 and count the frequency. Then from the frequncy, you can calculate the number of pairs.

If you still can't figure out the solution, take a look at my own solution.

Keep in mind that, when you need to calculate the number of pairs, besides merge sort, frequncy can also be very helpful!!!!!!!!!!/////<<<<<<<<<


159. https://leetcode.com/problems/count-pairs-in-two-arrays/

How would you implement this?

Crealy brutfornce will take O(n^2) and get TLE. I remember Sohan talked about this problem. He used merge sort. This problem does actually look like merge sort. How would you solve this?

I couldn't formulate it in merge sort.

Now, how would you implement this?

This solution came from https://leetcode.com/problems/count-pairs-in-two-arrays/solutions/3005095/c-binary-search-o-n-log-n/

Intuition
--------------------
a[i]+a[j] > b[i]+b[j]
a[i]+a[j]  (b[i]+b[j]) > 0
(a[i]b[i]) + (a[j]b[j]) > 0

Now we can have a diff array where diff[i] = a[i] - b[i].

Now we simply need to find how many pair (i, j) in diff array where diff[i] + diff[j]  > 0;


How can we solve this?

We can sort the diff array. If it's sorted, we don't need to check all the numbers for each number. Rather we can stop early.

Take a look at my own solution if you can't figure out the solution.

160. https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/

https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/

Implement using both extra space and O(1) space.

How would you do that?

If you can't figure out the solution, take a look at my own solution.

161. https://leetcode.com/problems/swap-nodes-in-pairs/

How would you do that?

If you can't figure out the solution, take a look at my own solution.

162. https://leetcode.com/problems/reverse-nodes-in-k-group/

Implemement using O(1) space, although think how would you implement if you can use extra space.

How would you do that?

If you can't figure out the solution, take a look at my own solution.

163. https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/

How would you implement this?

Hard part is how can you effciently check if subarray sum is 0. Naive algorithm will take O(n^2). Can you do it it O(n)?

Think about it. For instance, your numbers are: 

3 4 -2 -2 5 7


If you take prefix sum:

3 7 5  3  8 15
^      ^ 
This can be pictualially shown as (numbers are different):

      |
      |       |
   |  |       |
|  |  |   |   |
|  |  |   |   |
-------------------
3  5  8   3   7
^         ^

It illustrates that if you get the same value multiple times, it means that sum of all the number between that two point is 0!!!!!!!!!/////<<<<<< 

I got the idea from leetcode offcial solution.

Use this approach to solve the problem. Note that, if prefix sum of index i is 3 and prefix sum of index j is 3 (j > i), all the numbers from i + 1,....j should be deleted. Note that, i-th number should not be deleted.///////<<<<<<<< 

Again if the prefix sum is 0, all the numbers from  the beginning to the current number should be deleted.

If you can't figure out the solution, take a look at my own solution.

164. https://leetcode.com/problems/beautiful-arrangement/

Very common problem in the interview!!!

How would you solve this?

I tried to find if we can find a good heuristic to apply greedy approch. So, I couldn't find such. At that, point the problem is obvious a backtracking problem. Now, can you solve it in a bottom-up approach like DP and will that be better?/////////<<<<<<<<<<<

I tried to implememt using bottom-up DP. But, found out it's getting TLE.!!!!///////<<<<<<<<<<<<<

Why is that? 

Here, DP and backtracking is actaully the same. You can not exploring less option by going through bottom up approch. So, it will not help!!!!!!!!!!!!/////<<<<<<<
It will also make thing worse, because you are coping elements unnncessarily from one stage to another stage which is expensive!!!!!//////////<<<<<<<<<


So, moral of the story: If DP doesn't explore fewer option, backtracking is better than DP!!!!!!!!//////<<<<<<<<

But, still take a look at DP solution for few implementation stuff. 

    int countArrangement(int n) {
        vector<vector<unordered_set<int>>> dp(n+1);

        vector<unordered_set<int>> v;
        for (int i = 1; i <= n; i++) {
            if (isBeautiful (i, n)) {
                v.push_back({i});///////<<<<<<You can create+initialize a set using {} (like a vector)
            }
        }
        dp[n] = v;
        for (int i = n - 1; i >= 1; i--) {
            for (int j = 1; j <= n; j++) {
                if (isBeautiful (j, i)) {
                    for (auto e : dp[i+1]) {
                        if (e.count(j) == 0) {
                            unordered_set<int> s = e;///<<<<<In DP, you are copying elements from one stage to another which is expensive. 
                                                     ////<<<<<<<Backtacking doesn
                            't need that.
                            s.insert(j);
                            dp[i].push_back(s);
                        }
                    }
                }
            }
        }
        return dp[1].size();
    }
    
    
Now, to solve it properly, implement backtracking solution.

Also, note that, if you ever feel like you are copiing elements from one stage to another stage of DP, but it's not really needed. You could simply have one copy, it's a symptom that the pronblem can be backtracking instead of DP.///<<<<

If you can't figure out the solution, take a look at my own solution.

165. https://leetcode.com/problems/reorganize-string/

How would you solve this?

If you can't figure out the solution, take a look at my own solution.   

166. https://leetcode.com/problems/remove-k-digits/

How would you solve this?

If you can't figure out the solution, take a look at my own solution.

167. https://leetcode.com/problems/find-k-closest-elements/

How would you solve this?

If you can't figure out the solution, take a look at my own solution. 

168. https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/

How would you solve this?

I tend to figure out a O(n^2). But, can you solve it in O(n)?///////<<<<<<<<<<<<<<<<<

If you think carefully, in O(n^2) solution, we iterating through all possible width and for each width, we iterate through all possible height. But, as we are only interested in max area, we can simply take the max_width and max_height and multupply that.////////////<<<<<<<<<<<<

If you can't figure out the solution, take a look at my own solution. 

Also note that, the problem asked us to modulo 10^9 + 7 solution.

You can do it by simply doing this:

return ((long long)max_width * max_height) % 1000000007;///////<<<<<<<<<<<<<<<<<<<<<<<

169. How do declare enum class?

class enum Direction {NORTH = 0, WEST, SOUTH, EAST};/////<<<Wrong, but I often try it

class Enum Direction {NORTH = 0, WEST, SOUTH, EAST};/////<<<Wrong, but I often try it

enum class Direction {NORTH = 0, WEST, SOUTH, EAST};////<<<<<<Right

170. Can you use arithmatic operator on enum?

Probably, probably not. But, I had issue adding/subtracting number to my enum variable. If you want to do that, better use an integer array. //////<<<<<<<<<<<<<<<

Moral of the story: DON'T USE ENUM TO REPTRESENT DIRECTION OR ANYTHING. USE int (You don't really need int array!!!!!!)//////<<<<<<<<<<


171. What's wrong with this code?

unordered_set<pair<int, int>, vector<pair<int, int>>, HashFunc> set;

It should be:

unordered_set<pair<int, int>, HashFunc> set;//<<<<<<Holy shit!!!! I'm mixing unordered_set and priority_queue!!!

172. https://leetcode.com/problems/robot-bounded-in-circle/

Very interesting and useful problem. There is a bunch of practical problems related to topology, networks planning, and password brute-forcing. For all these problems, the first thing to understand is do we work within a limited space or the behavior of our system could drastically diverge at some point?////<<<<<


How would you solve this?

My hunch is to use a set. When you visit a point, add it to the set. If you come back to any point visited before, there is cycle. Now, question is how many iteration would you check before reaching to the the cycle? My hunch says 4 :-)  ///<<<<<<<<

This solution will work!!! But, note that, here cycle means it needs to come back to (0, 0), not just any visited point. So, you don't really need to maintain a set. Just do 4
iteration; after each iteration check if you reached (0, 0)///<<<<<<<<

That approch works. But, can you do better?

leetcode solution says that is a theoretical proof that you can find it with just one iteration. If you come back to (0, 0) after first iteration or if your direction is not NORTH after the first iteration, then it will come back to (0, 0)./////////////////<<<<<<<<<<<<<<<<<

Use the above approach

173. https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description/

Very very very very interesting problem!!

How would you implement this?

You can use trie. But, how would you construct the trie? Also is there a simpler approach than trie? Do you consider all the bit or only the bit needed?///////<<<<<

You should only use the bits that matter. But, is there a simple approach to to know how many bits you should consider?

You can find the maximum number and calculate the number of bits in the number!!!!!!!!////////<<<<<<<<<

Now, can we solve it without creating Trie? Trie sounds like an overkill.

We can solve it using set (as suggested in leetcode solution). When iterating the array, we store the key in the set. If we find the opposite already exist in the set, then we can say that position will be 1.


Based on the idea, I implemented following:

class Solution {
public:
    int findMaximumXOR(vector<int>& nums) {
        int n = nums.size();
        int max_elem = *max_element (nums.begin(), nums.end());
        int num_bits = log10 (max_elem)/log10(2) + 1;

        int res = 0;
        for (int i = num_bits; i >= 1; i--) {
            int mask = 1 << (i-1);
            unordered_set<int> set;

            for (auto e : nums) {
                if (set.count(((e >> (i-1)) & 1) ^ 1)) {
                    res |= mask;
                    break;
                }
                set.insert((e >> (i-1)) & 1);
            }
        }
        return res;
    }
};

But, this will not work!!!!!!!!!!!!!!!////////<<<<<<<

Why? 

Let us assume that nums is:

  3           10            5             25               2               8
------------------------------------------------------------------------------------
00011       01010         00101         11001            00010           01000


The above code will do the following://////<<<<<<<

 In each itertion from MSB to LSB:
     check if there is 0 and 1 bits in the corresponding position of the number; if yes, the result's corresponding bit should be 1.
     
     
But, this is not right. Actual algorithm should partition the numbers in each iteration as:


itr 0:    [00011  01010  00010  01000]  [11001]
itr 1:    [00011  00010]   [11001]   ----->>>01010, 01000 will not result largest XOR
itr 2:....

So, this is not a good candidate for set. This actually resembles to Trie.//////<<<<<<<

Now, if you still want to implememnt this using set, how would you do that?//////<<<<<<<

Here we cleverly need to create key in each iteration. I later realized that this clever key generation is not really worth it. Also, note that, as leetcode mentions, this set based approach is less efficient than trie based apprach, because here we explore many options which we wouldn''t in tree based approch.//////<<<<<<<


This is why even though we set out to implement set/hash and trie based approch, we will implement on trie based approch.


Now, how would you implememt using Trie?

First, need to construct the Trie. How would you do that?

I consider partitioning the array repeatedly based on bit position. But, you realize that would be insane :) Cost of doing that will be extremly high//////<<<<<


So, how would you do that?

Like what we did before. Add one number to trie at a time.////////<<<<<<<


Now, you have created the Trie. How would you find the largest XOR from trie?///////////<<<<<<<<

This may look simple. I tried to do recursion on Trie (like calculting height of the Trie) to find out the largest number. But, it's really hard!!!!!!!!//////<<<<<<<<<<<<

So, leetcode suggested an approach where for each number, find the number in Trie that gives the largest XOR. This is easy. Just one way trie travarsal from root to leaf. In this way find the max XOR.

MORAL: IF YOU NEED TO TRAVARSE MULTIPLE PATH OF THE TRIE AT THE SAME TIME, YOU ARE DOING IN WRONG. DEVELOP YOUR ALGORITHM SUCH A WAY THAT YOU ONLY TRAVARSE ONE PATH FROM ROOT TO LEAF./////<<<<<<<<

If the solution itsn't clear, take a look at leetcode solution or my my own solution.

174. How to calculate the number of bits in a number?

        int num_bits = log10 (max_elem)/log10(2) + 1;
             
Now, what's wrong with this?

log10(0) is undefine!!!!!!!!///<<<<<<

So, the right solution would be:        

     int num_bits = max_elem == 0 ? 1 : log10 (max_elem)/log10(2) + 1;////////<<<<<<
     
175. https://leetcode.com/problems/is-graph-bipartite/

How would you implement this?

Very very very interesting problem!!!!!

I tend to do this:

 For each node n://////<<<<<
    get list of nodes adjacent to node n. Let's say if the list is L, check if there is edge betweeen any of the two nodes in L; if yes, then it's not a bipartite graph.
    
    
But, that solution will not work!!!!!!!/////<<<<<

Why?

That solution will ensure that it's possible to group the nodes such that there is no edge between the nodes in the same group. But, it doesn't ensure that # of groups is 2. For instance, you can have this graph: The above algorithm will say it's a bi-partite graph although it's not.



4-------1
|         \
|          3
|         /
2-------0

Here, adjacent list is:

0 --> 2 , 3
1 --> 3, 4
2 --> 0, 4
3 --> 0, 1
4 --> 1, 2

There is no edge between any two nodes in the adjacency list (same arrow). However, it's not a bi-partite graph. 
 
Now, again, how would you solve this?

I tend to come up with union-join apprach. Here, I maintain two sets. I then iterate each edge, for ech end point of the edge, I try to add the two points to two sets.////<<<<<<

This approach may work, but, if you try to implement it, it's too clumsy!!!!!!!//////<<<<<<<<


How can you simplify this?

I then tend to iterate over the nodes instead of edges. I maintain two set. I iterate over the nodes. At each iteration, I try to add the node to one of the set. /////<<<<<<

But, this simple apprach may add a node to wrong set. ////<<<<<<<

To solve the problem, I sort the nodes based on dergrees. I insert nodes with highest degree first. This approach sound like it will work. And it does work most of the time. But, it may not work all of the time because we don't have any correctness proof.///////////<<<<<<


How can we then solve this?


Note that, even though it's a graph problem, we use traditional data structure such set and has to solve the problem. We so far tried to use common sense which doesn't seem to be working!!!!///////////<<<<<<<<<<<<

So, how can we solve this????

This is actually a graph coloring problem. This is same as checking if the graph can be colored with 2 colors such that adjacent nodes don't have the same color.////<<<<<

This can be solved using BFS + graph coloring. This has been proposed in leetcode and geekforgeeks:

https://leetcode.com/problems/is-graph-bipartite/solutions/127708/is-graph-bipartite/
https://www.geeksforgeeks.org/bipartite-graph/

If you can't figure out the solution, take a look at my own solution.

176. https://leetcode.com/problems/possible-bipartition/description/

How would you implememt this?

if you can't figure out the solution, take a look at my own solution.

177. For instance, you are given this graph. How would you implememt topological sorting?


4------->1
^        ^
|         \
|          3
|          ^       
|         /
2------->0

What I tend to do is calculate indegrees of all the nodes. Start with an 0 indegree node and do DFS. This approach is clumsy and not efficient./////<<<<<<<

Can you do topological sorting using DFS starting from any node?////////////////<<<<<<<

Thankfully, you can !!!!!!!!!//////<<<<<<<<<<<<<<

For instance, start with 3. Then  you will visit 1 and 3 (note we visit depth first). Then start with 2. Then you will visit 4, 0 and 2. 
If we put them side by side, you get:////<<<<<<<<<<<<<<

[1, 3] [4, 0, 2]

So, your result is:

[1, 3, 4, 0, 2]

If you just reverse it, you get:

[2, 0, 4, 3, 1].


Instead of reversing these, you can store them in a stack. Then reversing is easy.

I got these idea from:

https://www.geeksforgeeks.org/topological-sorting/

Note that, sometimes I forget that in DFS, I visit the depth node first and start node last. I tend to think in my mind visiting start, then incrementally go into depth, but that's not the case. We visit the start last. //////////////////<<<<<<<<<<<<<<<<<<<<<<<<<<<<

If you keep that mind, you can visualize why DFS will work even if you start from any node.

178. https://leetcode.com/problems/alien-dictionary/

How would you implement this?

Very very intesrting problem. If you can't figure out the solution, take a look at my own solution.


MORAL: IF YOU NEED SOME SORT OF ORDERING, IT CAN BE A GRAPH PROBLEM!!!!!!!!!!!!!!!!!!!!!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

179. https://leetcode.com/problems/longest-consecutive-sequence/

How would you implement this?

Another very very very intesresting problem!

Also, the problem isn't very clear. What does it mean by sequnce? Here, they mean longest range where each element of the range is a member of the array.///////<<<<<<<<


How would you implement this?

Note that, if you have ordering, you can represent this as a graph. You can use DFS to find the longest sequnce. How would you use sequential DFS to implement this? Can you use arbitarry node as start?/////////<<<<<<<<<<<<

No, we shouldn't. That would be unnecessary!!!! Although we were able to perform toplogical sorting woth DFS with any start node, that approach should be used here. Here, we need to find out the longest consecutive sequnce. So, we really should find a node with 0 indegree as start node. This is not only fine but also necessary/////<<<<

Now, how would you implememnt sequential DFS. This is a psudocode:

                stack<int> s;/////<<<<<<Use a stack.
                unordered_set<int> visit;////<<<<Keep track of nodes that are being visited

                s.push(e);
                while (!s.empty()) {
                    int cur = s.top();
                    if (visit.count(cur)) {///<<<<<<<Don't pop stack immediately. Only delete it if the visit is true (i.e. it's already expanded). This is super important to remember
                                           /////<<<<<<Here, visit == true means, the node has been expanded.
                        res = max<long> (res, s.size());
                        s.pop();
                        continue;
                    }
                    visit.insert(cur);
                    for (auto adj : adjList[cur]) {
                    	if (visit.count(adj))
                        	s.push(adj);
                    }
                }
                
How does it compare with recursive DFS?

    void dfs (unordered_map<char, vector<char>> &adjList,
                char start, unordered_map<char, int> &visit,
                vector<char> &res, bool &cycle) {
        visit[start] = 1;////<<<<<When visit for the first time, mark it as 1. That means it's on the path
        for (auto ch : adjList[start]) {
            if (visit[ch] == 1) {////<<<<<<If we come accross a node with visit 1, that means we found a loop.
                cycle = true;
                return;
            }
            if (visit[ch] == 0) {///<<<<<Expand the node 
                dfs (adjList, ch, visit, res, cycle);
                if (cycle)
                    return;
            }
        }
        visit[start] = 2;////<<<<<<If we are here, means all the subsequnt nodes has been visited, so mark it as 2 (dead)
        res.push_back(start);
    }                

Note that recursive approach needs to 2 color whereas sequntiual approach needs one color. In DFS, we really need to distinguish between dead node and active nodes on the path, so we use 2 color approach. In sequential solution, one color + stack is enough./////<<<<<<<<<<<<<<<<<<<<<<<


Now, if you use traditional sequntila DFS, you will get TLE for this problem.////////<<<<<<<

In this problem, each node will have just one successor. So, do we still need stack or recursive DFS? //////////<<<<<<

No, we can implement a DFS using a simple loop because there will be just one path.//////////<<<<<<<<

If you can't figure out the solution, take a look at my own solution.//////<<<<<<<<<<<<<<<<<<

180. https://leetcode.com/problems/satisfiability-of-equality-equations/description/

Very very very very interesting problem!!!!!

How would you solve this?

If you can't figure out the solution, take a look at leetcodee solution or my own solution.

One more question? Do you use DFS or BFS here?/////////<<<<<<<<<<<<<<<<<<

You can do both. In DFS in undirected graph, how would you prevent from next node to come back to the currennt node??????????///////////////////////////<<<<<<<<<<<<

When we add a node to stack, mark it as visited[node] = 1. It means that, node is already added. When adding to node to stack, we need to check if visit[node] == 1; if yes, node is already added to stack, no node need to add any more. This will prevent from next node to coming back to current node.!!!!!!!/////////////////////////<<<<<<<<<<<<<<<<<<<

When we expand a node, we need to mark it as  visited[node] = 2 (dead).  This will distinguish a node from active (on the path) to dead node.//////<<<<<<

Note that, previously I thought I don't need two color in DFS if I use stack. But, that's not true. We still need two color if we want to implememt DFS properly. But, many be not needed in directed graph!!!!!!!!!!!!//////<<<<<<<<<<<


181. https://leetcode.com/problems/longest-string-chain/

How would you implement this?

I tend to use DFS which is fine. Now few questions:///////<<<<<<<<<<<<<<<<

a. How can implement DFS such that it would work for undirected graph? DFS doesn't really need two color, but we want to implement using two color to practice undirected graph.
b. How can you find all the nodes with 0 indegrees?
c. How can you find the maximum depth in DFS?

Answer of b: Note that, finding elements with 0 indegress will require checking each edge again. Instead maintain a list of nodes that don't have 0 indegreess. It's easier to calculate. When 
add an edge a->b, add b to the list.//////////<<<<<<

Answer of c: I take max of stack size here. But, will it work? No, think about this graph://////////////<<<<<<<<<<<<<<

b     bca------->bdca
\      ^           ^
 \    /            |
  v  /             |
   ba------------>bda 
  ^
 /
a


Here, if we start with b, we will add ba, then we will add bca and bda, then we will add bdca. Note that, stack size doesn't really represent the real depth. In DFS, we need to calculate the depth manually./////////<<<<<<<<<<<


The code shows all the tricks.

    int dfs (string &start) {
        int res = 0;

        stack<string> s;
        unordered_map<string, int> visit;
        s.push(start);
        int depth = 0;
        while (!s.empty()) {
            string cur = s.top();
            if (visit[cur] == 2) {//////<<<<<The node is expanded, need to be deleted. Don't delete all the top of the stack
                res = max(res, depth);//////<<<<Max depth is calculated based on depth variable instead of stack size. I mistakenly use stack size often
                depth--;////<<<<<<<<<We reached the end of a path, so decrease the depth
                s.pop();
                continue;
            }
            for (auto str : adjList[cur]) {
                if (visit[str] == 2)////////<<<<<The node is already expanded
                    continue;
                visit[str] = 1;//////<<<<<Means it's already added to stack, but not expanded
                s.push(str);
            }
            depth++;/////////<<<<<Increaing the path
            visit[cur] = 2;
        }
        return res;
    }
public:
    int longestStrChain(vector<string>& words) {
        n = words.size();
        unordered_set<string> not_indegree_zero;/////<<<Mainintain a list of nodes whose indegrees are not 0, it's easy to create instead of 0-indegree nodes

        sort (words.begin(), words.end(), [](string &s1, string &s2) {
            return s1.length() < s2.length(); 
        });

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (words[i].length() == words[j].length())
                    continue;
                if (words[i].length() + 1 < words[j].length())
                    break;
                if (isPredeccessor(words[i], words[j])) {
                    adjList[words[i]].push_back(words[j]);
                    not_indegree_zero.insert(words[j]);///////<<<<<Add to the list
                }
            }
        }

        int res = 0;
        for (int i = 0; i < n; i++) {
            if (not_indegree_zero.count(words[i]))//////<<<< If a node already in not_indegree_zero list, ignore it
                continue;
            int len = dfs (words[i]);
            res = max (res, len);
        }
        return res;
    }
};
 
182. https://leetcode.com/problems/regions-cut-by-slashes/description/


Very intersting problem!!


How would you solve this? If you can't figure out, take a look at leetcode solution or my own solution. 

Note that, here I tend to create 2 nodes per cell. But, it's very difficult to implemement the logic that way. As suggested in leetcode, if you divide each cell into 4 nodes, it becomes very easy.

183. https://leetcode.com/problems/tree-diameter/

How would you solve it?

I tend think of cutting off leaves at each step, and counting the path. I had an issue to solve this problem with that approach. Remember that, we are trying to find centraoid in this way. Problem is centraoid can be or two node. So, if I only have two node, i should stop.//////////////<<<<<<<<<<<<<<<<<<<<

Now, leetcode suggested to use the same approach to find centraoid. Then from centroid to do BFS to find two longest path. ////////<<<<<<

This is an interesting approach too. But, I think, cacluating it while calculating centraoid would be more efficient./////<<<<

 

